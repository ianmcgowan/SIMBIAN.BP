***************************************************************************
* Program: STACK
* Author : Ian McGowan
* Created: 1989-06-13
* Updated: 2024-08-21
* Comment: Stacks TCL commands, utilities for programmers
***************************************************************************
CRT \Version 2024-08-21 Pickle Blob\
*
* STACK is a command line editor, command stack, program stack and useful utilites for TCL
* It is designed to make life easier and more productive for programmers
* It is a single program, so it can be used on any Unidata system, and is easy to install
* The only dependency is the ability to create STACK.HOME in the account, or a QPTR to a file in a central location
*
* STACK functions can be divided into 5 categories:
* 1) Line editing commands     - Editing the current command line, aims to be bash-like, allows custom key bindings
* 2) Command stack commands    - Manipulating the command stack, like .L, .X in TCL - fewer options, since you can edit the stack
* 3) Program stack commands    - Manipulating the program stack, saves typing ED BP PROGRAM.NAME, just do /E3
* 4) Internal utility commands - Utilities that are built into STACK that are useful for programmers in general
* 5) InfoLease utilities       - Utilities that are useful for InfoLease programmers
*
STACK.HELP=''
STACK.HELP<-1>='--------------------- TCL STACK COMMANDS (vt100)-------------------------------'
STACK.HELP<-1>='Ctrl-A      Start of line (home)       Ctrl-R           Search                 '
STACK.HELP<-1>='Ctrl-B      Back character (left)      Ctrl-U           Page Up (pgup)         '
STACK.HELP<-1>='Ctrl-D      Delete character (del)     Ctrl-V           Page Down (pgdown)     '
STACK.HELP<-1>='Ctrl-E      End of line (end)          Ctrl-W           Delete word            '
STACK.HELP<-1>='Ctrl-F      Forward character (right)  Ctrl-X           Back word              '
STACK.HELP<-1>='Ctrl-G      Cancel line (esc)          ~xyz             List ALL xyz in stack  '
STACK.HELP<-1>='Ctrl-I      Forward Word (tab)         @xyz             Recall LAST xyz        '
STACK.HELP<-1>='Ctrl-K      Delete to end              .D               Toggle detail off/on   '
STACK.HELP<-1>='Ctrl-L      Clear screen               .Lm,n            List entry m thru n    '
STACK.HELP<-1>='Ctrl-M      Accept line (enter)        .Rn              Restore entry n, edit  '
STACK.HELP<-1>='Ctrl-N      Next line (down)           .H/?             Help                   '
STACK.HELP<-1>='Ctrl-P      Previous line (up)         Q/INFO           Quit/InfoLease         '
STACK.HELP<-1>='                                                                               '
STACK.HELP<-1>='---------------------- PROGRAM STACK COMMANDS ---------------------------------'
STACK.HELP<-1>='/           List the programs in the current project                           '
STACK.HELP<-1>='/LL         List available projects    /L BLAH          Switch to project BLAH '
STACK.HELP<-1>='/Nx         Add New program at posn x  /Fx              Format the x`th program'
STACK.HELP<-1>='/Ex         Edit the x`th program      /WW              Edit the program list  '
STACK.HELP<-1>='/Wx         VI the x`th program        /S               Sort the program stack '
STACK.HELP<-1>='/Bx         Compile the x`th program   /BR              Compile and run        '
STACK.HELP<-1>='                                                                               '
STACK.HELP<-1>='---------------------------- UTILITIES ----------------------------------------'
STACK.HELP<-1>='{C}CI/CM/TM {Customer}Contract Inquiry/Maint/Table Maint             CI 100.1.1'
STACK.HELP<-1>='AF          ATB Finder, search definitions                            AF MRKTNG'
STACK.HELP<-1>='BPI         List table definitions                          BPI LS.CTD.PYMTHIST'
STACK.HELP<-1>='CHECK.FILE  Show strings in a compiled program /P|/S      CHECK.FILE DISP.00 /P'
STACK.HELP<-1>='CT          View data records, with labels         CT LS.MASTER 123-1234567-000'
STACK.HELP<-1>='DDD         Search dictionary definitions                   DDD LS.MASTER EQUIP'
STACK.HELP<-1>='DESC        Describe columns in a table                  DESC LS_OI_CTD_INVOICE'
STACK.HELP<-1>='DIFF        Compare two files, show differences                            DIFF'
STACK.HELP<-1>='FIELD       Show IL10 attribute/field metadata              FIELD LS.NET.INVEST'
STACK.HELP<-1>='FIND.MENU   Search the menus                                     FIND.MENU VOID'
STACK.HELP<-1>='ICONV/OCONV Test format masks/Convert Data                                     '
STACK.HELP<-1>='KEYS        Show ASCII key values (try hitting arrow or home/end keys)         '
STACK.HELP<-1>='LIST.KEYS   Show current key bindings                                          '
STACK.HELP<-1>='LISTA       Show users logged in, as well as locks                             '
STACK.HELP<-1>='MODULES     Show available/active modules                               MODULES'
STACK.HELP<-1>='NED         Edit an IL10 record                   NED LS.MASTER 123-1234567-000'
STACK.HELP<-1>='NSEL        Run a simple UD command   NSEL LS.INV.NUM N.CONTRACT.KEY N.DATE.DUE'
STACK.HELP<-1>='PARAM       Show parameter file mapping                               PARAM INV'
STACK.HELP<-1>='PICKLE      Store data records in prog       PICKLE DICT LS.MASTER UATB.BIG.ATB'
STACK.HELP<-1>='PIVOT       Summary data                  PIVOT LS.MASTER LESSOR GROSS.CONTRACT'
STACK.HELP<-1>='PROF        Profile data       PROF LS.MASTER BRANCH NUM.OF.ASSETS BOOKING.DATE'
STACK.HELP<-1>='RS          Edit a recall                                       RS DK.AUDIT.RPT'
STACK.HELP<-1>='RULER       Reset term width, show ruler                                       '
STACK.HELP<-1>='SETTINGS    Change settings                                                    '
STACK.HELP<-1>='SF          Search files and dictionaries              SF DICT LS.MASTER ASSETS'
STACK.HELP<-1>='SQL         Run a SQL command -SQL SELECT TOP 10 ALTERNATE_ID FROM LS_MASTER_NF'
STACK.HELP<-1>='SQL-LIST    SQL to L1 -SQL-LIST L1 SELECT TOP 10 ALTERNATE_ID FROM LS_MASTER_NF'
STACK.HELP<-1>='SQLF        Run a SQL command from a file          SQLF /tmp/queries/Query1.sql'
STACK.HELP<-1>='TRAIN       Teach STACK your key bindings interactively                        '
STACK.HELP<-1>='XREF        Show IL10 file/table metadata                        XREF LS.MASTER'
*
PROMPT ''
EQUATE RET TO 13, ESC TO 27, NUL TO '',SPC TO ' ',TRUE TO 1, FALSE TO 0
EQUATE SEARCH.ALL.CHAR TO '~', UNIX TO '!', SEARCH.NEXT.CHAR TO '@', BELL TO CHAR(7), OTHERWISE TO 1
DIM RECORD.DATA(10)
TERM=UPCASE(SYSTEM(7))
CS=@(-1);EOL=@(-4);EOS=@(-3);UP=@(-10);BON=@(-81);BOFF=@(-82)
IF SYSTEM(33) = "Windows NT" THEN OS.PATH.DELIM = "\" ELSE OS.PATH.DELIM = "/"
LONG.LINE = 9999;LIST.DET.FLAG=0;TIME.COMMAND=0
SL.ACTIVE = FALSE
*
PWD=@ACCOUNT
I=LEN(PWD) ; ACC=NUL
FOR F=I TO 1 STEP -1
  IF PWD[F,1] = OS.PATH.DELIM THEN EXIT
  ACC=PWD[F,1]:ACC
NEXT F
*
OPEN 'VOC'    TO VOC    ELSE STOP 201,'VOC'    ;* Big problems if this isn't there
OPEN '_HOLD_' TO HOLD   ELSE STOP 201,'_HOLD_' ;* Used as temporary table
OPEN 'CTLGTB' TO CTLGTB ELSE STOP 201,'CTLGTB' ;* Global catalog
OPEN 'CTLG'   TO CTLG   ELSE STOP 201,'CTLG'   ;* Local catalog
*
USERNAME=UPCASE(@LOGNAME)
HOME.FILE   = 'STACK.HOME'        ;* Everything is stored in this file
DIR=HOME.FILE ; GOSUB OPEN.DIR ; HOME.F=FVAR   ;* This can be local, or pointed to a central location for all accounts
READV HOME.DIR FROM VOC, HOME.FILE, 2 ELSE HOME.DIR=''
*
STACK.ITEM  = USERNAME:'.COMMAND' ;* Stores the command stack for each user
PROGRAM.ITEM= USERNAME:'.PROGRAM' ;* Stores the program stack for each user (may be multiple projects)
ALIAS.ITEM  = USERNAME:'.ALIAS'   ;* Stores aliases for each user
SETTING.ITEM= USERNAME:'.SETTING' ;* Stores settings for each user
KEYMAP.ITEM = USERNAME:'.KEY'     ;* Stores key bindings for each user
*
SETTINGS      = ';'        ;* DEFAULT COMMAND SEPERATOR
SETTINGS<2>   = '.'        ;* DEFAULT STACK CHAR
SETTINGS<3>   = '/'        ;* DEFAULT PROG CHAR
SETTINGS<4>   = 9999       ;* DEFAULT MAX # LINES IN STACK
SETTINGS<5>   = '!vi'      ;* DEFAULT SCREEN EDITOR (try !joe :)
SETTINGS<6>   = 'AE'       ;* DEFAULT LINE EDITOR
SETTINGS<7>   ='* Edited :';* DEFAULT HEADER STRING
SETTINGS<8>   = TRUE       ;* DEFAULT USE GET.LINE SUBR
SETTINGS<9>   = 'BP.DEV'   ;* DEFAULT WORK FILE
SETTINGS<10>  = FALSE      ;* DEFAULT = CONVERT TO UCASE
SETTINGS<11>  = ""         ;* DEFAULT STARTUP COMMAND
SETTINGS<12>  = "#R#H:#A>" ;* DEFAULT PROMPT
SETTINGS<13>  = -2         ;* DEFAULT X DISPLACEMENT FOR PROMPT
IF OS.PATH.DELIM = "\" THEN
  SETTINGS<14>= "cmd"      ;* DEFAULT SHELL FOR WINDOWS COMMANDS
END ELSE
  SETTINGS<14>= "bash -i"  ;* DEFAULT SHELL FOR UNIX COMMANDS
END
SETTINGS<15>  =  "DEFAULT" ;* DEFAULT PROJECT
*
* Merge the settings from the file with the defaults
READ R FROM HOME.F, SETTING.ITEM ELSE R=NUL
I=DCOUNT(SETTINGS,@AM)
FOR F=1 TO I
  IF R<F> # NUL THEN SETTINGS<F> = R<F>
NEXT F
*
* Now apply the settings
COMMAND.SEPERATOR = SETTINGS<1>
STACK.CHAR        = SETTINGS<2>
PROG.CHAR         = SETTINGS<3>
MAX.STACK         = SETTINGS<4>
WP.VERB           = SETTINGS<5>
ED.VERB           = SETTINGS<6>
STAMP.STRING      = SETTINGS<7>
GET.LINE.FLAG     = SETTINGS<8>
WORK.FILE         = SETTINGS<9>
MCU.ON            = SETTINGS<10>
STARTUP           = SETTINGS<11>
PROMT             = SETTINGS<12>
X.DISP            = SETTINGS<13>
DEF.SHELL         = SETTINGS<14>
PROJ.NAME         = SETTINGS<15>
WRITE SETTINGS ON HOME.F, SETTING.ITEM
*
* Built-in editing commands, can be bound to new keys as needed
KEYCOMMLIST=''
KEYCOMMLIST<1,-1>='{Backspace}'   ; KEYCOMMLIST<2,-1>='Delete the character to the left of the cursor'
KEYCOMMLIST<1,-1>='{BackWord}'    ; KEYCOMMLIST<2,-1>='Move back a word'
KEYCOMMLIST<1,-1>='{Clear}'       ; KEYCOMMLIST<2,-1>='Clear the screen'
KEYCOMMLIST<1,-1>='{Delete}'      ; KEYCOMMLIST<2,-1>='Delete the character to the right of the cursor'
KEYCOMMLIST<1,-1>='{DeleteLine}'  ; KEYCOMMLIST<2,-1>='Clear from the cursor to end of command'
KEYCOMMLIST<1,-1>='{DeleteWord}'  ; KEYCOMMLIST<2,-1>='Delete the word to the right of the cursor'
KEYCOMMLIST<1,-1>='{Down}'        ; KEYCOMMLIST<2,-1>='Go to the next command'
KEYCOMMLIST<1,-1>='{End}'         ; KEYCOMMLIST<2,-1>='Go to the end of the command'
KEYCOMMLIST<1,-1>='{Enter}'       ; KEYCOMMLIST<2,-1>='Submit the current command'
KEYCOMMLIST<1,-1>='{ForwardWord}' ; KEYCOMMLIST<2,-1>='Move forward a word'
KEYCOMMLIST<1,-1>='{Home}'        ; KEYCOMMLIST<2,-1>='Go to the start of the command'
KEYCOMMLIST<1,-1>='{Left}'        ; KEYCOMMLIST<2,-1>='Move one character to the left'
KEYCOMMLIST<1,-1>='{PgDown}'      ; KEYCOMMLIST<2,-1>='Show the next page of commands'
KEYCOMMLIST<1,-1>='{PgUp}'        ; KEYCOMMLIST<2,-1>='Show the previous page of commands'
KEYCOMMLIST<1,-1>='{Quit}'        ; KEYCOMMLIST<2,-1>='Cancel the current command'
KEYCOMMLIST<1,-1>='{Right}'       ; KEYCOMMLIST<2,-1>='Move one character to the right'
KEYCOMMLIST<1,-1>='{Search}'      ; KEYCOMMLIST<2,-1>='Interactive Search'
KEYCOMMLIST<1,-1>='{Up}'          ; KEYCOMMLIST<2,-1>='Go to the previous command'
*
READ KEYMAP FROM HOME.F, KEYMAP.ITEM ELSE
  CRT 'First STACK run, assuming Putty/VT100 key mapping'
  GOSUB KEY.DEFAULTS
END
*
PROGRAM.ITEM=USERNAME:'.PROGRAM_':PROJ.NAME
READ PROGRAMS FROM HOME.F, PROGRAM.ITEM ELSE PROGRAMS = NUL
*
EXEC.LINE="!hostname" ; CAP.ACTIVE=TRUE ; GOSUB EXEC.SUB
HOST.NAME=EXEC.CAP<1>
*
READ STACK FROM HOME.F, STACK.ITEM ELSE STACK = NUL
CRT DCOUNT(STACK,@AM):' commands in stack ':HOME.DIR:OS.PATH.DELIM:STACK.ITEM
READ ALIASES FROM HOME.F, ALIAS.ITEM ELSE ALIASES = NUL
*
* IL9/IL10 Check
IL.DB=''
IL.VER=''
IL.MAJOR.VER=''
REV.ATB.LOG=''
OPEN 'ACCOUNT.PARAMS' TO ACCOUNT.PARAMS THEN
  READ VERSION FROM ACCOUNT.PARAMS, 'VERSION' ELSE VERSION=''
  IL.DB=PWD
  IL.VER=VERSION<4>:'/':VERSION<8>:'.':VERSION<26>
  IL.MAJOR.VER=9
  OPEN 'REV.ATB.LOG' TO REV.ATB.LOG ELSE STOP 201,'REV.ATB.LOG'
  DB='UD'
END ELSE
  OSREAD JDBC FROM 'DBConfig.xml' THEN
    CONVERT CHAR(13) TO '' IN JDBC
    CONVERT CHAR(10) TO @AM IN JDBC
    JDBC=JDBC<2> ;* <DataSource>InfoLease</DataSource>
    JDBC=FIELD(JDBC,'>', 2)
    JDBC=FIELD(JDBC,'<', 1)
    IF JDBC # '' THEN
      OSREAD JDBC.P FROM '../../jdbc-bridge/bin/jdbc.properties' THEN
        CONVERT CHAR(13) TO '' IN JDBC.P
        CONVERT CHAR(10) TO @AM IN JDBC.P
        FOR F=1 TO DCOUNT(JDBC.P,@AM)
          L=JDBC.P<F>
          IF JDBC=FIELD(L,'.',1) AND INDEX(L,'url',1) THEN IL.DB=L ; EXIT
        NEXT F
      END
    END
    IF INDEX(UPCASE(IL.DB),'ORACLE',1) THEN DB='ORA' ELSE DB='MSSQL'
    OSREAD VER FROM 'version.properties' ELSE VER='il.version=10'
    CONVERT CHAR(13) TO '' IN VER
    CONVERT CHAR(10) TO @AM IN VER
    FOR F=1 TO DCOUNT(VER,@AM)
      IF FIELD(VER<F>,'=',2) # '' THEN IL.VER=FIELD(VER<F>,'=',2) ; EXIT
    NEXT F
    IL.MAJOR.VER=10
  END
END
IF IL.MAJOR.VER # '' THEN
  CRT IL.VER:' ':IL.DB
  CRT ; CRT 'INFO to return to Infolease'
END
CRT '? for Help'
*
* You can put commands in the startup file, e.g. .L ; LISTA ; DATE
OLD.X.DISP=X.DISP
SHOW.SELECT=0
RTN=NUL
TERM.WIDTH=80
IF STARTUP # NUL THEN ANS=STARTUP ; GOSUB COMMAND ; STARTUP=NUL
ANS=NUL
*******************************************************************************
* MAIN LOOP - THIS RUNS UNTIL THE USER QUITS
*******************************************************************************
LOOP
  GOSUB GET.TERM.WIDTH ;* In case terminal font or window size changes
  GOSUB EXPAND.PROMPT
  CRT BON:PROMPT.DISP:BOFF:
  X = LEN(PROMPT.DISP) + X.DISP
  ENTRY = NUL;LEN = LONG.LINE;DISP.LEN=TERM.WIDTH-1-X;LINE.NUM=0
  GOSUB GET.LINE
  ANS=ENTRY
  * Reread the program and command stack, since they may be modified in another session
  READ PROGRAMS FROM HOME.F, PROGRAM.ITEM ELSE PROGRAMS = NUL
  READ STACK FROM HOME.F, STACK.ITEM ELSE STACK = NUL
  READ ALIASES FROM HOME.F, ALIAS.ITEM ELSE ALIASES = NUL
  IF RTN # ESC THEN GOSUB COMMAND
REPEAT
*******************************************************************************
* COMMAND PROCESSING
*******************************************************************************
COMMAND:
  * Process the command line entered - split on COMMAND.SEPERATOR, unless it's a unix command or search
  MAX.STACK=DCOUNT(STACK,@AM)
  IF ANS = '' THEN RETURN
  UNIX.COMMAND = FALSE
  OLD.STACK = STACK
  COMMAND.LIST = ANS
  COMMAND.COUNT = 1
  BEGIN CASE
    CASE ANS[1,1] = SEARCH.NEXT.CHAR
      ANS=ANS[2,999]
      GOSUB SEARCH.NEXT
      IF ENTRY='' THEN RETURN
      CRT BON:PROMPT.DISP:BOFF:
      GOSUB GET.LINE
      ANS=ENTRY
      GOTO COMMAND
    CASE ANS[1,1]=UNIX
      UNIX.COMMAND=TRUE
      * Don't look for ; for unix commands
      GOSUB DO.COMMAND
    CASE 1
      LOOP
        ANS = FIELD(COMMAND.LIST,COMMAND.SEPERATOR,COMMAND.COUNT)
      UNTIL ANS = NUL DO
        GOSUB DO.COMMAND
        COMMAND.COUNT = COMMAND.COUNT + 1
      REPEAT
  END CASE
RETURN
*
DO.COMMAND:
  * Process a single command
  IF NOT(UNIX.COMMAND) THEN
    * Only uppercase, expand aliases, expand prog chars for non-unix commands
    IF MCU.ON THEN ANS = TRIM(UPCASE(ANS))
    IF ANS[1,5] # 'ALIAS' THEN GOSUB EXPAND.ALIASES
    GOSUB EXPAND.PROG.CHARS
  END
  IF ANS=UNIX THEN ANS=UNIX:DEF.SHELL ;* Entering ! is the same as !cmd or !bash -i
  IF ANS='?' THEN ANS='.H'
  LEN.ANS = LEN(ANS)
  CAP.ACTIVE=FALSE
  FIRST.WORD=FIELD(ANS,' ',1)
  UPDATE.STACK.FLAG=TRUE
  COMMANDS='AF,ALIAS,BPI,CCI,CCM,CHECK.FILE,CI,CM,CT,DDD,DESC,DIFF,FIELD,FIND.MENU,ICONV,KEYS,LIST.KEYS,SQL-LIST,LISTA,MODULES,'
  COMMANDS:='NED,NSEL,OCONV,OFF,PARAM,PICKLE,PIVOT,PROF,KEY.DEFAULTS,Q,RS,RULER,SE,SETTINGS,SF,SQL,SQLF,TM,TRAIN,XREF'
  CONVERT ',' TO @VM IN COMMANDS
  LOCATE FIRST.WORD IN COMMANDS<1> SETTING INTERNAL.COMMAND ELSE INTERNAL.COMMAND=''
  *
  BEGIN CASE
    CASE INTERNAL.COMMAND
      ON INTERNAL.COMMAND GOSUB ATB.FIND, DO.ALIAS, BPI, CCI, CCM, CHECK.FILE, CI, CM, VIEW.RECORD, DDD, IL10.DESC, DIFF, IL10.FIELD,
                                FIND.MENU, CONV, KEYS, LIST.KEYS, SQL.SEL.LIST, LISTA, LIST.MODULES, IL10.NED, IL10.NSEL, CONV,
                                QUIT, LIST.PARAM, PICKLE, PIVOT, PROFILE, KEY.DEFAULTS, QUIT, RS, RULER, SEARCH.EXAMPLE, SETTINGS,
                                SEARCH.FILE, SQL.SEL, SQL.FILE, TM, TRAIN, IL10.XREF
    CASE ANS[1,1] = STACK.CHAR
      * E.g. .L .X20 .D
      ANS = TRIM(UPCASE(ANS))
      GOSUB STACK.COMMAND
      UPDATE.STACK.FLAG=FALSE
    CASE ANS[1,1] = PROG.CHAR
      * E.g. /E10 /N3 /BR20
      ANS = TRIM(UPCASE(ANS))
      GOSUB PROG.COMMAND
      UPDATE.STACK.FLAG=FALSE
    CASE ANS[1,1] = SEARCH.ALL.CHAR
      * E.g. ~xyz
      ANS=ANS[2,999]
      GOSUB SEARCH.ALL
      UPDATE.STACK.FLAG=FALSE
    CASE OTHERWISE
      * A plain old command to execute
      EXEC.LINE = ANS
      T1=SYSTEM(12)
      GOSUB EXEC.SUB
      IF TIME.COMMAND THEN PRINT SYSTEM(12)-T1:' ms'
  END CASE
  IF UPDATE.STACK.FLAG THEN
    INS ACC:@VM:DATE():@VM:TIME():@VM:ANS BEFORE STACK<1>
    WRITE STACK ON HOME.F, STACK.ITEM
  END
RETURN
*
OPEN.DIR:
  * Open a local directory, create if missing
  OPEN DIR TO FVAR ELSE
    EXECUTE \CREATE.FILE DIR \:DIR
    OPEN DIR TO FVAR ELSE STOP 'Cannot open or create ':DIR
  END
RETURN
*
DO.ALIAS:
  * ALIAS command - 1) list all aliases, 2) list one alias, 3) set an alias
  AL = FIELD(ANS,SPC,2)
  STRING = NUL;I = 3
  LOOP
    F = FIELD(ANS,SPC,I)
  UNTIL F = NUL DO
    STRING = STRING:SPC:F
    I = I + 1
  REPEAT
  BEGIN CASE
    CASE AL = NUL AND STRING = NUL
      GOSUB LIST.ALIAS
    CASE STRING = NUL
      GOSUB LIST.ONE.ALIAS
    CASE 1
      GOSUB SET.ALIAS
  END CASE
RETURN
*
QUIT:
  * Quit STACK, saving the command and program stacks
  GOSUB WRITE.INFO
  STOP
RETURN
*
WRITE.INFO:
  * Save everything when exiting
  WRITE STACK ON HOME.F, STACK.ITEM
  WRITE ALIASES ON HOME.F, ALIAS.ITEM
  WRITE PROGRAMS ON HOME.F, PROGRAM.ITEM
  WRITE SETTINGS ON HOME.F, SETTING.ITEM
RETURN
*
REMOVE.CONTROL.CHARS:
  * Remove control characters from ANS, useful for pasting from excel
  ANS=OCONV(ANS,'MCP')
  CONVERT '~' TO '' IN ANS
RETURN
*
SET.ALIAS:
  * Set an alias, e.g. ALIAS L=LIST LS.MASTER WITH NUM.OF.ASSETS > "0", and then L CUST.CREDIT.ACCT CBR LS.NET.INVEST
  STRING=STRING[2,LONG.LINE]
  PRINT AL:'=':STRING
  LOCATE AL IN ALIASES<1> BY 'AL' SETTING P THEN
    ALIASES<2,P> = STRING
  END ELSE
    INS AL BEFORE ALIASES<1,P>;INS STRING BEFORE ALIASES<2,P>
  END
  WRITE ALIASES ON HOME.F, ALIAS.ITEM
RETURN
*
LIST.ALIAS:
  * List all aliases
  I = DCOUNT(ALIASES<1>,@VM)
  FOR F = 1 TO I
    PRINT ALIASES<1,F>,ALIASES<2,F>
  NEXT F
RETURN
*
LIST.ONE.ALIAS:
  * List one alias
  LOCATE AL IN ALIASES<1> BY 'AL' SETTING P ELSE PRINT AL:' not found';RETURN
  X=0;LEN=99;DISP.LEN=30;ENTRY=ALIASES<2,P>
  GOSUB GET.LINE
  IF RTN = 27 THEN RETURN
  ALIASES<2,P> = ENTRY
  IF ENTRY = NUL THEN DEL ALIASES<1,P>;DEL ALIASES<2,P>
  WRITE ALIASES ON HOME.F, ALIAS.ITEM
RETURN
*
EXEC.SUB:
  * Execute a command, capturing the output if necessary
  IF EXEC.LINE = NUL THEN RETURN
  IF EXEC.LINE = 'CLEARSELECT' THEN CLEARSELECT ; RETURN
  IF CAP.ACTIVE THEN
    EXECUTE EXEC.LINE CAPTURING EXEC.CAP
  END ELSE
    EXECUTE EXEC.LINE
  END
  IF SYSTEM(11) > 0 THEN SL.ACTIVE = TRUE ELSE SL.ACTIVE = FALSE
  CAP.ACTIVE=FALSE
RETURN
*
EXPAND.PROG.CHARS:
  * expand //10 to be USER.DEFINED.BP MY.LONG.PROGRAM, so CATALOG //10 DIRECT FORCE works for example
  * also: can add D for directory or P for program, so AE VOC //10P will run AE VOC MY.LONG.PROGRAM
  POS = 1
  LOOP
    I = INDEX(ANS,PROG.CHAR:PROG.CHAR,POS)
  UNTIL I = 0 DO
    VAR = NUL;IDX = I+2
    LOOP
      C = ANS[IDX,1]
    UNTIL NOT(NUM(C)) OR C = NUL DO
      VAR = VAR:C
      IDX = IDX+1
    REPEAT
    BEGIN CASE
      CASE ANS[IDX,1]='D'
        REPLACE=FIELD(PROGRAMS<VAR>,' ',1)
        IDX+=1
      CASE ANS[IDX,1]='P'
        REPLACE=FIELD(PROGRAMS<VAR>,' ',2)
        IDX+=1
      CASE OTHERWISE
        REPLACE=PROGRAMS<VAR>
    END CASE
    IF NUM(VAR) AND VAR > 0 THEN
      ANS = ANS[1,I-1]:REPLACE:ANS[IDX,LONG.LINE]
    END ELSE
      POS = POS + 1
    END
  REPEAT
RETURN
*
EXPAND.ALIASES:
  * Expand aliases, before executing a command
  SWAP SPC WITH @VM IN ANS ; POS = 1
  LOOP
    R = ANS<1,POS>
  UNTIL R = NUL DO
    LOCATE R IN ALIASES<1> BY 'AL' SETTING P THEN ANS<1,POS> = ALIASES<2,P>
    POS = POS + 1
  REPEAT
  SWAP @VM WITH SPC IN ANS
RETURN
*
EXPAND.PROMPT:
  * Dynamic prompt, I like #R#U@#H:#A> - X.DISP is the number of characters to remove from the LEN so the
  * input starts at the right place.  #R adds two to the length, but displays on another line, so X.DISP=-2 fixes that
  IF SL.ACTIVE THEN
    PROMPT.DISP='#R':SYSTEM(11):'-SEL>'
    OLD.X.DISP=X.DISP
    X.DISP=-2
  END ELSE
    PROMPT.DISP = PROMT
    X.DISP=OLD.X.DISP
  END
  CTR = 1
  LOOP
    I = INDEX(PROMPT.DISP,'#',CTR)
  UNTIL I = 0 DO
    F = PROMPT.DISP[I+1,1]
    L = PROMPT.DISP[1,I-1];R = TRIM(PROMPT.DISP[I+2,LONG.LINE])
    BEGIN CASE
      CASE F = 'B'
        PROMPT.DISP = L:CHAR(7):R
      CASE F = 'A'
        PROMPT.DISP = L:ACC:R
      CASE F = 'T'
        PROMPT.DISP = L:OCONV(TIME(),'MTS'):R
      CASE F = 'D'
        PROMPT.DISP = L:OCONV(DATE(),'D'):R
      CASE F = 'E'
        PROMPT.DISP = L:CHAR(ESC):R
      CASE F = 'R'
        PROMPT.DISP = L:CHAR(13):CHAR(10):R
      CASE F = '#'
        PROMPT.DISP = L:'#':R
        CTR = CTR + 1
      CASE F = 'U'
        PROMPT.DISP = L:USERNAME:R
      CASE F = 'H'
        PROMPT.DISP=L:FIELD(HOST.NAME,".",1):R
      CASE OTHERWISE
        CTR = CTR + 1
    END CASE
  REPEAT
RETURN
*******************************************************************************
* COMMAND STACK PROCESSING
*******************************************************************************
LIST.STACK:
  * List entries from P2->P1, Defauts: P1=1, P2=20
  I = DCOUNT(STACK,@AM)
  IF I = 0 THEN PRINT 'No items present';RETURN
  IF P2 > I THEN P2 = I
  PRINT
  FOR F = P2 TO P1 STEP -1
    IF LIST.DET.FLAG THEN
      PRINT SPC:F'R#5':" ":STACK<F,1>'L#20':' ':OCONV(STACK<F,2>,'D-YMD'):' ':OCONV(STACK<F,3>,'MTS'):' ':STACK<F,4>
    END ELSE
      PRINT SPC:F'R#5':" ":STACK<F,4>
    END
  NEXT F
RETURN
*
STACK.COMMAND:
  * Process a STACK command, e.g. .L .X20 .D
  BEGIN CASE
    CASE ANS='.D'
      LIST.DET.FLAG=NOT(LIST.DET.FLAG)
    CASE ANS[1,2] = '.L'
      IF ANS = '.L' THEN ANS = '.L,20'
      GOSUB GET.PARAMS
      IF RANGE.ERROR THEN RETURN
      GOSUB LIST.STACK
    CASE ANS = '.P'
      PRINT '#R - Return  #A - Account  #D - Date  #T - Time #P - Port'
      PRINT '#E - Escape  #L - Level    #U - User  #H - Host'
      PRINT 'Prompt':
      X = 7;DISP.LEN = 60;ENTRY = PROMT;LEN = 99;GOSUB GET.LINE
      PROMT = ENTRY
      PRINT 'Enter the X displacement for input :':
      ENTRY = NUL;LEN = 5;DISP.LEN = 5;X = 37;GOSUB GET.LINE
      X.DISP = ENTRY
      IF NOT(NUM(X.DISP)) THEN X.DISP = 0
      SETTINGS<12> = PROMT
      SETTINGS<13> = X.DISP
      OLD.X.DISP=X.DISP
    CASE ANS = '.H'
      FOR F=1 TO DCOUNT(STACK.HELP,@AM)
        CRT STACK.HELP<F>
      NEXT F
    CASE ANS = '.T'
      TIME.COMMAND=NOT(TIME.COMMAND)
    CASE ANS = '.U'
      IF MCU.ON THEN MCU.ON = FALSE;PRINT 'upper case off' ELSE MCU.ON = TRUE;PRINT 'UPPER CASE ON'
    CASE OTHERWISE
      PRINT 'There is no such STACK command':BELL
      PRINT '? for help'
  END CASE
RETURN
*
GET.PARAMS:
  * Get the numeric parameters for a stack command, e.g. .L1,20 P1=1 P2=20
  I = INDEX(ANS,',',1)
  IF I # 0 THEN
    L = I-1;P1 = NUL
    LOOP
      IF NUM(ANS[L,1]) THEN P1 = ANS[L,1]:P1;L=L-1 ELSE EXIT
    REPEAT
    P2 = ANS[I + 1, LEN.ANS]
  END ELSE
    P1 = NUL
    LOOP
      IF NUM(ANS[LEN.ANS,1]) THEN P1 = ANS[LEN.ANS,1]:P1;LEN.ANS=LEN.ANS-1 ELSE EXIT
    REPEAT
    IF P1 = NUL THEN P1 = 1
    P2 = P1
  END
  IF P1 = NUL THEN P1 = 1
  IF P2 = NUL THEN P2 = MAX.STACK
  IF NUM(P1) & NUM(P2) & P1 > 0 THEN
    RANGE.ERROR = FALSE
  END ELSE
    RANGE.ERROR = TRUE
    PRINT 'Range Error':BELL
  END
RETURN
*
SEARCH.ALL:
  * Search the command stack and show lines that contain ANS
  FOR F=DCOUNT(STACK,@AM) TO 1 STEP -1
    IF INDEX(UPCASE(STACK<F,4>),UPCASE(ANS),1) THEN
      IF LIST.DET.FLAG THEN
        PRINT SPC:F'R#5':" ":STACK<F,1>'L#20':' ':OCONV(STACK<F,2>,'D-YMD'):' ':OCONV(STACK<F,3>,'MTS'):' ':STACK<F,4>
      END ELSE
        PRINT SPC:F'R#5':" ":STACK<F,4>
      END
    END
  NEXT F
RETURN
*
SEARCH.NEXT:
  * Search the command stack for the most recent ANS and execute that line
  ENTRY=''
  FOR F=1 TO DCOUNT(STACK,@AM)
    IF INDEX(UPCASE(STACK<F,4>),UPCASE(ANS),1) THEN
      ENTRY=STACK<F,4>
      RETURN
    END
  NEXT F
RETURN
*******************************************************************************
* PROGRAM STACK PROCESSING
*******************************************************************************
PROG.COMMAND:
  * Process a PROG command, e.g. /E10 /N3 /BR20
  IF ANS = PROG.CHAR OR ANS=PROG.CHAR:PROG.CHAR THEN GO PRINT.PROG.INFO
  PROG.NUM = NUL
  F = FIELD(ANS,SPC,1);L = LEN(F);I = L
  LOOP
    IF NUM(F[I,1]) THEN PROG.NUM = F[I,1]:PROG.NUM ELSE EXIT
    I = I - 1
  REPEAT
  IF PROG.NUM = NUL THEN PROG.NUM = 1
  OPTIONS = ANS[L+1,LONG.LINE]
  PROG.COM = ANS[1,I]
  PROG = PROGRAMS<PROG.NUM>
  B.FILE = FIELD(PROG,SPC,1)
  B.ITEM = FIELD(PROG,SPC,2)
  ANS=PROG.COM:SPC:B.FILE:SPC:B.ITEM
  BEGIN CASE
    CASE PROG.COM = '/WW'
      WRITE PROGRAMS ON HOME.F, PROGRAM.ITEM
      WP.FILE=HOME.FILE
      WP.ITEM=PROGRAM.ITEM
      GOSUB WP.EDIT
      READ PROGRAMS FROM HOME.F, PROGRAM.ITEM ELSE PROGRAMS = NUL
    CASE PROG.COM = '/WE'
      WRITE PROGRAMS ON HOME.F, PROGRAM.ITEM
      EXECUTE \ED \:HOME.FILE:\ \:PROGRAM.ITEM
      READ PROGRAMS FROM HOME.F, PROGRAM.ITEM ELSE PROGRAMS = NUL
    CASE PROG.COM = '/N'
      GOSUB GET.PROG.NAME
      IF RTN=13 THEN
        PROGRAMS<PROG.NUM> = PROG
        WRITE PROGRAMS ON HOME.F, PROGRAM.ITEM
      END
      IF B.FILE # '' THEN
        OPEN B.FILE TO F THEN
          OPTIONS=''
          READ DUMMY FROM F, B.ITEM ELSE
            PRINT B.ITEM:' not found.  Use standard header? ':
            INPUT YORN
            IF YORN = 'Y' THEN
              D=OCONV(DATE(),"D-YMD")
              HEADER=STR('*',80)
              HEADER<2>='* Program: ':B.ITEM
              HEADER<3>='* Author : ':USERNAME
              HEADER<4>='* Created: ':D ;* E.g. 2017-04-20
              HEADER<5>='* Updated: ':D ;* E.g. 2017-04-20
              HEADER<6>='* Comment: Do NOT skip the description'
              HEADER<7>=STR('*',80)
              HEADER<8>='* Date       User    Comment'
              HEADER<9>='* ---------- ------- -----------------------------------------------------------'
              HEADER<10>='* ':D:' ':USERNAME'L#7':' Created'
              WRITE HEADER ON F, B.ITEM
            END
          END
          CLOSE F
          WP.FILE=B.FILE
          WP.ITEM=B.ITEM
        END ELSE
          PRINT B.FILE:' is not a file in this account'
        END
      END
    CASE PROG.COM = '/L'
      * Load a new program stack for a project
      OLD.PROJ.NAME=PROJ.NAME ; OLD.PROGRAMS=PROGRAMS
      PROJ.NAME=TRIM(OPTIONS)
      IF PROJ.NAME='' THEN PROJ.NAME='DEFAULT'
      PROGRAM.ITEM=USERNAME:'.PROGRAM_':PROJ.NAME
      READ PROGRAMS FROM HOME.F, PROGRAM.ITEM ELSE
        CRT PROJ.NAME:' not found, create? ':
        INPUT YORN
        IF YORN # 'Y' THEN PROJ.NAME=OLD.PROJ.NAME ; PROGRAMS=OLD.PROGRAMS ; RETURN
        PROGRAMS = NUL
      END
      SETTINGS<15>=PROJ.NAME
      GOSUB PRINT.PROG.INFO
      GOSUB WRITE.INFO
    CASE PROG.COM = '/LL'
      * List the different projects
      EXEC.LINE=\SSELECT \:HOME.FILE:\ WITH @ID = "\:USERNAME:\.PROGRAM_]"\
      CAP.ACTIVE=TRUE ; GOSUB EXEC.SUB
      LOOP
        READNEXT ID ELSE EXIT
        PRINT FIELD(ID,'_',2,99)
      REPEAT
    CASE B.FILE[1,1] = '*' OR B.FILE=''
      NULL ;* Don't do anything with 'comment' or blank entries in the program stack
    CASE PROG.COM = '/BR'
      GOSUB COMPILE
      EXEC.LINE = B.ITEM
      GOSUB EXEC.SUB
    CASE PROG.COM = '/B'
      GOSUB COMPILE
    CASE PROG.COM = '/E' OR PROG.COM = '/W'
      OPEN B.FILE TO F ELSE PRINT 'Cannot open ':B.FILE:BELL;RETURN
      READ R1 FROM F, B.ITEM ELSE R1=NUL
      IF PROG.COM = '/E' THEN
        EXEC.LINE = ED.VERB:SPC:PROG:OPTIONS
        GOSUB EXEC.SUB
      END ELSE
        WP.FILE=B.FILE
        WP.ITEM=B.ITEM
        GOSUB WP.EDIT
      END
      CLOSE F
    CASE PROG.COM = '/F'
      GOSUB BFORMAT
    CASE PROG.COM = '/R'
      OPEN B.FILE TO F ELSE PRINT 'Cannot open ':B.FILE:BELL;RETURN
      READV R FROM F, B.ITEM, 1 ELSE R=NUL
      CLOSE F
      EXEC.LINE = B.ITEM:OPTIONS
      GOSUB EXEC.SUB
    CASE PROG.COM = '/S'
      * A slow sort of the program stack
      READ REC FROM HOME.F, PROGRAM.ITEM ELSE PRINT 'CANNOT READ ':HOME.FILE:' ':PROGRAM.ITEM ; RETURN
      SORT='AL' ; NEW.REC=''
      I=DCOUNT(REC,@AM)
      FOR F=1 TO I
        L=REC<F>
        IF L = '' THEN CONTINUE
        LOCATE L IN NEW.REC BY SORT SETTING POS ELSE NULL
        INS L BEFORE NEW.REC<POS>
      NEXT F
      WRITE NEW.REC ON HOME.F, PROGRAM.ITEM
    CASE OTHERWISE
      PRINT 'There is no such PROGRAM command':BELL
      PRINT '? for help'
  END CASE
RETURN
*
COMPILE:
  * Compile a program, and catalog the way it is currently cataloged
  OPTIONS=''
  * Check for global catalog
  READ DUMMY FROM CTLGTB, B.ITEM THEN
    PRINT B.ITEM:' is cataloged globally'
    OPTIONS='G'
  END
  *
  * Check for local catalog
  READ DUMMY FROM CTLG, B.ITEM THEN
    PRINT B.ITEM:' is cataloged locally'
    OPTIONS :='L'
  END
  *
  * Check for direct catalog
  READ DUMMY FROM VOC, B.ITEM THEN
    IF INDEX(DUMMY<2>,'/CTLG/',1)=0 THEN
      PRINT B.ITEM:' is cataloged direct to ':DUMMY<2>
      OPTIONS :='D'
    END
  END
  *
  IF LEN(OPTIONS) > 1 THEN
    PRINT "OPTIONS=":OPTIONS
    PRINT "I do not like green eggs and ham, nor do I like"
    PRINT "programs cataloged twice.  You must fix, Sam"
    PRINT 'Fix now? Y/N:':
    INPUT YORN
    IF YORN = 'Y' THEN
      EXEC.LINE=\DECATALOG \:B.ITEM
      CRT EXEC.LINE ; CAP.ACTIVE=TRUE ; GOSUB EXEC.SUB
      CRT EXEC.LINE ; CAP.ACTIVE=TRUE ; GOSUB EXEC.SUB
      CRT EXEC.LINE ; CAP.ACTIVE=TRUE ; GOSUB EXEC.SUB
      GOTO COMPILE ;* Try again
    END
  END
  *
  LOOP
  UNTIL OPTIONS#'' DO
    PRINT 'Catalog ':B.ITEM:' -- D)irect, L)ocal or G)lobal :':
    INPUT OPTIONS
    OPTIONS=UPCASE(OPTIONS)
    IF OPTIONS = '/' OR OPTIONS='' THEN RETURN
    * Have to enter D, L or G
    IF OPTIONS # 'L' AND OPTIONS # 'G' AND OPTIONS # 'D' THEN OPTIONS=''
  REPEAT
  *
  EXEC.LINE = 'BASIC ':B.FILE:' ':B.ITEM:' -D' ;* -D includes symbol table
  PRINT EXEC.LINE
  GOSUB EXEC.SUB
  *
  BEGIN CASE
    CASE OPTIONS='G'
      EXEC.LINE = 'CATALOG ':B.FILE:' ':B.ITEM:' FORCE'
      PRINT EXEC.LINE
      GOSUB EXEC.SUB
    CASE OPTIONS='L'
      EXEC.LINE = 'CATALOG ':PROG:' LOCAL FORCE'
      PRINT EXEC.LINE
      GOSUB EXEC.SUB
      * Object is in CTLG file, so remove from SOURCE file
      OPEN B.FILE TO F ELSE PRINT 'Cannot open ':B.FILE:BELL;RETURN
      DELETE F, '_':B.ITEM
      CLOSE F
    CASE OPTIONS='D'
      EXEC.LINE = 'CATALOG ':B.FILE:' ':B.ITEM:' DIRECT FORCE'
      PRINT EXEC.LINE
      GOSUB EXEC.SUB
  END CASE
  *
  EXEC.LINE = 'NEWPCODE' ;* This loads a new version of globally cataloged programs (except for STACK)
  GOSUB EXEC.SUB
RETURN
*
GET.PROG.NAME:
  * Add a program to the current project, e.g. 3=USER.DEFINED.BP INVOICE.PRINT.INTERFACE.00
  X = 15;DISP.LEN = 50;LEN = LONG.LINE;ENTRY = PROG
  PRINT 'Program Name :':
  GOSUB GET.LINE
  ANS = UPCASE(ENTRY)
  IF RTN # 13 THEN RETURN
  IF INDEX(ANS,SPC,1) THEN
    B.FILE = FIELD(ANS,SPC,1)
    B.ITEM = FIELD(ANS,SPC,2)
    PROG=ANS
  END ELSE
    IF ANS = NUL THEN
      B.FILE = NUL ; B.ITEM = NUL ;PROG = NUL
    END ELSE
      B.FILE = WORK.FILE ; B.ITEM = ANS ; PROG = B.FILE:SPC:B.ITEM
    END
  END
RETURN
*
PRINT.PROG.INFO:
  * List the program stack for the current project
  I = DCOUNT(PROGRAMS,@AM)
  PRINT 'PROJECT=':PROJ.NAME
  FOR F = 1 TO I
    IF PROGRAMS<F> # NUL THEN
      PRINT F 'L#5':' ':PROGRAMS<F>
    END
  NEXT F
RETURN
*******************************************************************************
* INTERNAL UTILITY COMMANDS
*******************************************************************************
PICKLE:
  * Pickle a record, e.g. to include as a snippet in a program to recreate the record
  PICKLE.LIST=''
  *
  IF FIELD(ANS,' ',2)='DICT' THEN
    FILE='DICT ':FIELD(ANS,' ',3)
    ITEM=FIELD(ANS,' ',4)
  END ELSE
    FILE=FIELD(ANS,' ',2)
    ITEM=FIELD(ANS,' ',3)
  END
  OPEN FILE TO FVAR ELSE
    PRINT 'Cannot open ':FILE
    RETURN
  END
  READ REC FROM FVAR, ITEM ELSE
    PRINT 'Cannot read ':FILE:' ':ITEM
    RETURN
  END
  BLOB='R=""'
  IF FILE[1,5]='DICT ' THEN DEL REC<9> ; DEL REC<8> ;* Avoid CD probs
  INS ITEM BEFORE REC<1>
  INS FILE BEFORE REC<1>
  SWAP @AM WITH '#AM#' IN REC   ; SWAP @VM WITH '#VM#' IN REC
  SWAP @SVM WITH '#SVM#' IN REC ; SWAP '\' WITH '#BS#' IN REC
  SWAP CHAR(9) WITH '#TAB#' IN REC
  FIRST=1
  LOOP
    T=REC[1,120]
    IF FIRST THEN BLOB<-1>='S=\':T:'\' ELSE BLOB<-1>='S:=\':T:'\'
    REC=REC[121,LEN(REC)]
    FIRST=0
  UNTIL LEN(REC)=0 DO
  REPEAT
  BLOB<-1>='R<-1>=S'
  BLOB<-1>='*'
  *
  * Write out basic code that when run will recreate the record
  BLOB<-1>='FOR F=1 TO DCOUNT(R,@AM)'
  BLOB<-1>='  REC=R<F>'
  BLOB<-1>='  SWAP "#AM#" WITH @AM IN REC   ; SWAP "#VM#" WITH @VM IN REC ; SWAP "#SVM#" WITH @SVM IN REC'
  BLOB<-1>='  SWAP "#TAB#" WITH CHAR(9) IN REC ; SWAP "#BS#" WITH "\" IN REC'
  BLOB<-1>='  FILE=REC<1> ; DEL REC<1>'
  BLOB<-1>='  ITEM=REC<1> ; DEL REC<1>'
  BLOB<-1>='  PRINT FILE:" ":ITEM:'
  BLOB<-1>='  OPEN FILE TO FVAR ELSE STOP 201, FILE'
  BLOB<-1>='  WRITE REC ON FVAR,ITEM'
  BLOB<-1>='  CLOSE FVAR'
  BLOB<-1>='NEXT F'
  FOR I=1 TO DCOUNT(BLOB,@AM)
    PRINT BLOB<I>
  NEXT I
RETURN
*
SETTINGS:
  * Display and edit the settings
  PRINT CS:
  PRINT 'COMMAND.SEP  = ':SETTINGS<1>
  PRINT 'STACK.CHAR   = ':SETTINGS<2>
  PRINT 'PROG.CHAR    = ':SETTINGS<3>
  PRINT 'MAX.STACK    = ':SETTINGS<4>
  PRINT 'WP.VERB      = ':SETTINGS<5>
  PRINT 'ED.VERB      = ':SETTINGS<6>
  PRINT 'STAMP.STRING = ':SETTINGS<7>
  PRINT 'GET.LINE.FLAG= ':SETTINGS<8>
  PRINT 'WORK.FILE    = ':SETTINGS<9>
  PRINT 'MCU.ON       = ':SETTINGS<10>
  PRINT 'STARTUP      = ':SETTINGS<11>
  PRINT 'PROMT        = ':SETTINGS<12>
  PRINT 'X.DISP       = ':SETTINGS<13>
  PRINT 'DEF.SHELL    = ':SETTINGS<14>
  PRINT ; PRINT 'Hit ENTER to accept the current default, / to Cancel'
  X=18
  LEN=30
  DISP.LEN=30
  *
  PRINT
  PRINT 'The command seperator is used to run multiple commands from one entry'
  PRINT 'E.g. COUNT VOC ; COUNT VOC WITH F1 = "C" will run both count commands'
  PRINT 'Current value:':SETTINGS<1>
  PRINT 'COMMAND SEPERATOR:':
  INPUT ENTRY
  IF ENTRY = '/' THEN RETURN
  IF ENTRY = ''  THEN ENTRY=SETTINGS<1>
  SETTINGS<1>=ENTRY
  *
  PRINT
  PRINT 'The stack character is what to prefix command stack operations with'
  PRINT 'E.g. .L or .R87 or .D uses a stack character of "."'
  PRINT 'Current value:':SETTINGS<2>
  PRINT 'STACK CHAR       :':
  INPUT ENTRY
  IF ENTRY = '/' THEN RETURN
  IF ENTRY = ''  THEN ENTRY=SETTINGS<2>
  SETTINGS<2>=ENTRY
  *
  PRINT
  PRINT 'The program character is what to prefix program stack operations with'
  PRINT 'E.g. /W2 or /B3 or /L uses a program character of "/"'
  PRINT 'Current value:':SETTINGS<3>
  PRINT 'PROG CHAR        :':
  INPUT ENTRY
  IF ENTRY = '/' THEN RETURN
  IF ENTRY = ''  THEN ENTRY=SETTINGS<3>
  SETTINGS<3>=ENTRY
  *
  PRINT
  PRINT 'Max lines is the maximum number of lines to hold in the command stack'
  PRINT 'E.g. 9999'
  PRINT 'Current value:':SETTINGS<4>
  PRINT 'MAX # LINES      :':
  INPUT ENTRY
  IF ENTRY = '/' THEN RETURN
  IF ENTRY = ''  THEN ENTRY=SETTINGS<4>
  SETTINGS<4>=ENTRY
  *
  PRINT
  PRINT 'Screen editor is what command to run to edit a program visually'
  PRINT 'E.g. VI or !emacs or !/home/dsiroot/joe'
  PRINT 'Current value:':SETTINGS<5>
  PRINT 'SCREEN EDITOR    :':
  INPUT ENTRY
  IF ENTRY = '/' THEN RETURN
  IF ENTRY = ''  THEN ENTRY=SETTINGS<5>
  SETTINGS<5>=ENTRY
  *
  PRINT
  PRINT 'Line editor is what command to run to edit a program'
  PRINT 'E.g. AE or ED'
  PRINT 'Current value:':SETTINGS<6>
  PRINT 'LINE EDITOR      :':
  INPUT ENTRY
  IF ENTRY = '/' THEN RETURN
  IF ENTRY = ''  THEN ENTRY=SETTINGS<6>
  SETTINGS<6>=ENTRY
  *
  PRINT
  PRINT 'Header string is not currently used'
  PRINT 'HEADER STRING    :':SETTINGS<7>
  *
  PRINT
  PRINT 'Use enhanced input commands, allowing editing with arrow keys'
  PRINT 'Or just use plain INPUT command'
  PRINT 'Current value:':SETTINGS<8>
  PRINT 'USE GET.LINE SUBR:':
  INPUT ENTRY
  IF ENTRY = '/' THEN RETURN
  IF ENTRY = ''  THEN ENTRY=SETTINGS<8>
  IF ENTRY='Y' OR ENTRY='1' THEN ENTRY='1' ELSE ENTRY='0'
  SETTINGS<8>=ENTRY
  *
  PRINT
  PRINT 'Default file for basic programs if none specifed'
  PRINT 'E.g. BP'
  PRINT 'Current value:':SETTINGS<9>
  PRINT 'WORK FILE        :':
  INPUT ENTRY
  IF ENTRY = '/' THEN RETURN
  IF ENTRY = ''  THEN ENTRY=SETTINGS<9>
  SETTINGS<9>=ENTRY
  *
  PRINT
  PRINT 'Convert commands to upper case before running'
  PRINT 'E.g. 1 or 0, Y or N'
  PRINT 'Current value:':SETTINGS<10>
  PRINT 'CONVERT TO UCASE :':
  INPUT ENTRY
  IF ENTRY = '/' THEN RETURN
  IF ENTRY = ''  THEN ENTRY=SETTINGS<9>
  IF ENTRY='Y' OR ENTRY='1' THEN ENTRY='1' ELSE ENTRY='0'
  SETTINGS<9>=ENTRY
  *
  PRINT
  PRINT 'Command to run when stack first starts'
  PRINT 'E.g. LISTUSER ; WHO'
  PRINT 'Current value:':SETTINGS<11>
  PRINT 'STARTUP COMMAND  :':
  INPUT ENTRY
  IF ENTRY = '/' THEN RETURN
  IF ENTRY = ''  THEN ENTRY=SETTINGS<11>
  SETTINGS<11>=ENTRY
  *
  PRINT
  PRINT 'Default Prompt to display, use .P to change this'
  PRINT 'PROMPT           :':SETTINGS<12>
  PRINT
  PRINT 'Adjustment for input position (if you use #R, then CR+LF is inserted,'
  PRINT 'and an adjustment of -2 is needed.  Use .P to change this'
  PRINT 'X DISP FOR PROMPT:':SETTINGS<13>
  *
  PRINT
  PRINT 'Default shell to use with !command'
  PRINT 'E.g. ksh, bash, /usr/bin/ksh, /opt/freeware/bin/bash'
  PRINT 'Current value:':SETTINGS<14>
  PRINT 'SHELL            :':
  INPUT ENTRY
  IF ENTRY = '/' THEN RETURN
  IF ENTRY = ''  THEN ENTRY=SETTINGS<14>
  SETTINGS<14>=ENTRY
  *
  WRITE SETTINGS ON HOME.F, SETTING.ITEM
RETURN
*
WP.EDIT:
  * Edit a record using a visual editor (e.g. vi, joe or emacs)
  DICT=0
  IF FIELD(WP.FILE,' ',1)='DICT' THEN WP.FILE=FIELD(WP.FILE,' ',2) ; DICT=1
  READ REC FROM VOC, WP.FILE ELSE PRINT WP.FILE:' - no VOC item' ; RETURN
  IF (REC<1>#'DIR' AND REC<1>#'LD') OR DICT THEN
    * Copy to a temp DIR type and edit there, ignore the race conditions!
    IF DICT THEN WP.FILE='DICT ':WP.FILE
    OPEN WP.FILE TO T ELSE PRINT WP.FILE:' - cannot OPEN' ; RETURN
    READ R FROM T, WP.ITEM ELSE PRINT WP.ITEM:' - not found' ; RETURN
    WRITE R ON HOLD, WP.ITEM
    WP.PATH='_HOLD_'
    DIR.TYPE=0
  END ELSE
    WP.PATH=REC<2>
    IF REC<1>='LD' THEN
      IF INDEX(FILE,',',1) THEN
        WP.PATH=REC<2>:FIELD(FILE,',',2)
      END ELSE
        WP.PATH=REC<2>:'/':FIELD(REC<2>,'/',DCOUNT(REC<2>,'/'))
      END
    END
    DIR.TYPE=1
  END
  EXEC.LINE=WP.VERB:' ':WP.PATH:'/':WP.ITEM
  GOSUB EXEC.SUB
  IF NOT(DIR.TYPE) THEN
    * Copy back to original location
    READ R FROM HOLD, WP.ITEM ELSE R=''
    WRITE R ON T, WP.ITEM
    CLOSE T
  END
RETURN
*
CHECK.FILE:
  * Check a binary compiled code file for strings, with flags for programs/subroutine names and file names
  PARAM.CTR=1 ; PROG.FLAG=0 ; FILE.FLAG=0 ; ALL.FLAG=0
  LOOP
    P=FIELD(ANS,' ',PARAM.CTR)
  UNTIL P='' DO
    IF P[1,1] = '/' THEN
      P=P[2,1]
      BEGIN CASE
        CASE P='P'
          PROG.FLAG=1
        CASE P='F'
          FILE.FLAG=1
        CASE P='A'
          ALL.FLAG=1
      END CASE
    END ELSE
      PROG=P
    END
    PARAM.CTR += 1
  REPEAT
  IF PROG.FLAG=0 AND FILE.FLAG=0 THEN ALL.FLAG=1
  *
  IF PROG # '' THEN
    READ CAT.PTR FROM VOC, PROG ELSE PRINT 'Cannot read VOC ':PROG ; RETURN
  END ELSE
    LOOP
      PRINT 'Enter the program to scan ':
      INPUT PROG
      IF PROG = '' OR PROG = '/' THEN RETURN
      READ CAT.PTR FROM VOC, PROG THEN EXIT
      PRINT 'Cannot read VOC ':PROG
    REPEAT
  END
  *
  EXECUTE "!strings ":CAT.PTR<2> CAPTURING R
  *
  FILE.LIST=''
  IF R # '' THEN
    I=DCOUNT(R,@AM)
    FOR F=1 TO I
      TEST.FILE=R<F>
      IF FILE.FLAG THEN
        OPEN TEST.FILE TO DUMMY THEN
          LOCATE TEST.FILE IN FILE.LIST BY 'AL' SETTING POS ELSE
            INS TEST.FILE BEFORE FILE.LIST<POS>
            PRINT 'FILE:':TEST.FILE
          END
          CLOSE DUMMY
        END
      END
      IF PROG.FLAG THEN
        READ DUMMY FROM VOC, TEST.FILE THEN
          *IF DUMMY = 'C' THEN PRINT 'PROG: ':TEST.FILE
          IF DUMMY<1>='C' THEN PRINT 'PROG: ':TEST.FILE'L#25':' ':DUMMY<2>
        END
      END
      IF ALL.FLAG THEN
        PRINT TEST.FILE
      END
    NEXT F
  END
RETURN
*
CONV:
  * Handy way to check ICONV/OCONV data
  LOOP
    PRINT 'Enter mask:':
    INPUT MASK
    IF MASK='' OR MASK='/' THEN RETURN
    PRINT 'Enter data:':
    INPUT DTA
    PRINT 'Result:':
    IF FIRST.WORD='ICONV' THEN PRINT ICONV(DTA,MASK) ELSE PRINT OCONV(DTA,MASK)
  REPEAT
RETURN
*
RULER:
  * Show a ruler for checking character widths
  GOSUB GET.TERM.WIDTH
  CRT 'Term width=':TERM.WIDTH
  FOR F=1 TO TERM.WIDTH
    C=SEQ(0)+MOD(F,10)
    IF MOD(F,10) THEN PRINT CHAR(C): ELSE PRINT ' ':
  NEXT F
  PRINT
  SUP.NEXT=0
  FOR F=1 TO TERM.WIDTH
    BEGIN CASE
      CASE MOD(F+1,10)=0 AND (F+1)/10 > 9
        PRINT (F+1)/10:
        SUP.NEXT=1
      CASE MOD(F,10)=0 AND F/10 <= 9
        PRINT F/10:
        SUP.NEXT=0
      CASE MOD(F,5)=0 AND NOT(SUP.NEXT)
        PRINT '+':
      CASE 1
        IF NOT(SUP.NEXT) THEN PRINT ' ':
        SUP.NEXT=0
    END CASE
  NEXT F
  PRINT
RETURN
*
GET.TERM.WIDTH:
  * Get the terminal width, either from the TERM environment variable or from tput
  * In unix we can detect changes to the terminal width dynamically, but in windows user has to set TERM 132 manually
  IF OS.PATH.DELIM = "\" THEN
    TERM.WIDTH=@CRTWIDE
  END ELSE
    OLD.TERM.WIDTH=TERM.WIDTH
    T='/tmp/':@LOGNAME:'.term'
    EXEC.LINE=\!tput cols > \:T ;* Always returns 80 if you capture, so use tmp file
    GOSUB EXEC.SUB
    EXEC.LINE=\!cat \:T
    CAP.ACTIVE=TRUE
    GOSUB EXEC.SUB
    TERM.WIDTH=EXEC.CAP<1>
    EXEC.LINE=\!rm \:T
    GOSUB EXEC.SUB
    IF OLD.TERM.WIDTH # TERM.WIDTH THEN
      EXEC.LINE=\TERM \:TERM.WIDTH
      GOSUB EXEC.SUB
    END
  END
RETURN
*
PIVOT:
  * Summarize a field, e.g. PIVOT LS.MASTER LESSOR GROSS.CONTRACT EQUIPMENT.COST
  IF IL.MAJOR.VER # 9 THEN PRINT 'Only works in IL9' ; RETURN
  FILE=FIELD(ANS," ",2) ; ATB =FIELD(ANS," ",3) ; ATB2=FIELD(ANS," ",4) ; ATB3=FIELD(ANS," ",5) ; ATB4=FIELD(ANS," ",6)
  OPEN "DICT ":FILE TO DICT ELSE PRINT "DICT ":FILE:' not a filename' ; RETURN
  READ UREC FROM DICT,"UATB.COUNTER" ELSE
    UREC=\I\;UREC<2>=\"1"\;UREC<4>=\CNTR\;UREC<5>=\8R\;UREC<6>=\S\
    WRITE UREC ON DICT,"UATB.COUNTER"
  END
  CLOSE DICT
  EXEC.LINE = \SORT \:FILE:\ BY \:ATB:\ BREAK-ON \:ATB:\ TOTAL UATB.COUNTER \
  IF ATB2 # "" THEN EXEC.LINE := \ TOTAL \:ATB2
  IF ATB3 # "" THEN EXEC.LINE := \ TOTAL \:ATB3
  IF ATB4 # "" THEN EXEC.LINE := \ TOTAL \:ATB4
  EXEC.LINE := \ (IDH \
  GOSUB EXEC.SUB
RETURN
*
PROFILE:
  * Profile a field, e.g. PROFILE LS.MASTER REQ.SIGNATURE.PHONE
  IF IL.MAJOR.VER # 9 THEN PRINT 'Only works in IL9' ; RETURN
  FILE=FIELD(ANS," ",2) ; ATB =FIELD(ANS," ",3) ; ATBS=FIELD(ANS," ",4,99)
  EXEC.LINE = \SORT \:FILE:\ WITH \:ATB:\ \:ATB:\ \:ATBS
  GOSUB EXEC.SUB
RETURN
*
DDD:
  * List all the dictionary entries for a Unidata file
  IF IL.MAJOR.VER # 9 THEN PRINT 'Only works in IL9' ; RETURN
  * Tweak DICT VOC with some pickle juice
  R    =\DICT VOC#AM#@ID#AM#D#AM#0#AM##AM#VOC#AM#30L#AM#S#AM#\
  R<-1>=\DICT VOC#AM#F1#AM#D#AM#1#AM##AM##AM#5L#AM#S#AM#\
  R<-1>=\DICT VOC#AM#F2#AM#D#AM#2#AM##AM##AM#50R#AM#S#AM#\
  OPEN 'DICT VOC' TO FVAR ELSE RETURN
  FOR F=1 TO DCOUNT(R,@AM)
    REC=R<F>
    SWAP "#AM#" WITH @AM IN REC
    FILE=REC<1> ; DEL REC<1>
    ITEM=REC<1> ; DEL REC<1>
    WRITE REC ON FVAR,ITEM
  NEXT F
  CLOSE FVAR
  *
  * List the DICT, e.g DDD AS.MASTER EQUIP
  FILE = FIELD(ANS," ",2)
  SSTR = FIELD(ANS," ",3)
  FIND.STR=""
  IF SSTR # "" THEN FIND.STR = \WITH @ID = "[\:SSTR:\]" \
  EXEC.LINE=\SORT DICT \:FILE:\ @ID F1 F2 BY F1 BY F2 \:FIND.STR:\ USING DICT VOC (I \
  GOSUB EXEC.SUB
RETURN
*
SEARCH.FILE:
  * Search a file for a string, e.g. SF USER.DEFINED.BP INTERFACE - a convenience wrapper around ESEARCH
  FILE = FIELD(ANS," ",2)
  ICTR=3
  IF FILE='DICT' THEN ICTR+=1 ; FILE='DICT ':FIELD(ANS," ",3)
  OPEN FILE TO FVAR ELSE PRINT FILE:' - not found' ; RETURN
  SSTR = FIELD(ANS," ",ICTR)
  IF SSTR='' THEN PRINT 'Search for:': ; INPUT SSTR
  IF SSTR='' THEN RETURN
  *
  SSTR1=UPCASE(SSTR)
  SSTR2=DOWNCASE(SSTR)
  SSTR3=OCONV(SSTR,"MCT")
  *
  DATA SSTR
  DATA SSTR1
  DATA SSTR2
  DATA SSTR3
  DATA ""
  EXEC.LINE=\ESEARCH \:FILE:\ WITH @ID # "_]" USING DICT VOC\ ; CAP.ACTIVE=TRUE
  GOSUB EXEC.SUB
  *
  CTR=0 ; FOUND.RECS=''
  LOOP
    READNEXT ID ELSE EXIT
    READ REC FROM FVAR, ID THEN
      IDX = INDEX(UPCASE(REC),SSTR1,1)
      IF IDX OR INDEX(UPCASE(ID),SSTR1,1) THEN
        CTR+=1
        FOUND.RECS<1,CTR>=ID
        IDX -= 10 ; IF IDX < 1 THEN IDX=1
        LINE=REC[IDX,45]
        CONVERT @VM TO "]" IN LINE
        CONVERT @AM TO "~" IN LINE
        LINE=OCONV(LINE,"MCP")
        FOUND.RECS<2,CTR>=LINE
      END
    END
  REPEAT
  CLOSE FVAR
  *
  QUIT = 0 ; CTR=1 ; MAX.ITEMS=DCOUNT(FOUND.RECS<1>,@VM)
  IF MAX.ITEMS=0 THEN PRINT SSTR:' Not found' ; RETURN
  HDR=@(-1):\SEARCHING FOR "\:SSTR1:\,\:SSTR2:\,\:SSTR3:\" IN \:FILE
  PRINT HDR
  LOOP
    PRINT CTR'R#4':' ':FOUND.RECS<1,CTR>'L#25':FOUND.RECS<2,CTR>'L#65'
    CTR+=1
    IF CTR/20=INT(CTR/20) THEN GOSUB SEARCH.FILE.PROMPT
    IF QUIT THEN RETURN
  REPEAT
RETURN
*
SEARCH.FILE.PROMPT:
  * Actions available when using SEARCH.FILE
  PRINT ; PRINT 'B)ack, E)dit #, V)iew #, W)P#, /:':
  INPUT OPTION
  BEGIN CASE
    CASE OPTION='B'
      CTR-=40
      IF CTR<1 THEN CTR=1
    CASE OPTION[1,1]='E'
      EXEC.LINE=ED.VERB:\ \:FILE:\ \:FOUND.RECS<1,OPTION[2,99]>
      GOSUB EXEC.SUB
      CTR-=20
      IF CTR<1 THEN CTR=1
    CASE OPTION[1,1]='W'
      WP.FILE=FILE
      WP.ITEM=FOUND.RECS<1,OPTION[2,99]>
      GOSUB WP.EDIT
      CTR-=20
      IF CTR<1 THEN CTR=1
    CASE OPTION[1,1]='V'
      PRINT CS:
      EXEC.LINE=\CT \:FILE:\ \:FOUND.RECS<1,OPTION[2,99]>
      GOSUB EXEC.SUB
      CTR-=20
      IF CTR<1 THEN CTR=1
      PRINT 'Press ENTER:':
      INPUT AAA
    CASE OPTION # ''
      * ENTER to keep moving forward
      QUIT=1
  END CASE
  PRINT HDR
RETURN
*
BFORMAT:
  * Format a program the way I like, not the way AE FORMAT does it
  STAR  = '*' ; COLON = ':' ; TAB=CHAR(9)
  IND = 0
  *
  * These are all commands that may have ELSE or THEN statements
  * (or blocks) following them
  SPECIAL.CASES = "GET":@AM:"INPUT":@AM:"LOCATE":@AM:"LOCK":@AM:"MATREAD":@AM:"MATREADU":@AM
  SPECIAL.CASES := "MATWRITE":@AM:"MATWRITEU":@AM:"OPEN":@AM:"PROCREAD":@AM
  SPECIAL.CASES := "PROCWRITE":@AM:"READ":@AM:"READNEXT":@AM:"READSEQ":@AM:"READT":@AM:"READU":@AM:"READV":@AM
  SPECIAL.CASES := "READVU":@AM:"REWIND":@AM:"SEEK":@AM:"WEOF":@AM:"WRITESEQ":@AM
  SPECIAL.CASES := "WRITET"
  *
  DEF.INDENT=2
  FORMATS=":":@VM:"BEGIN":@VM:"CASE":@VM:"ELSE":@VM:"END":@VM:"FOR":@VM
  FORMATS :="IF":@VM:"LOOP":@VM:"NEXT":@VM:"REPEAT":@VM:"RETURN":@VM
  FORMATS :="THEN":@VM:"UNTIL":@VM:"WHILE"
  * THIS.IND is the amount this line will be in or outdented
  FORMATS<2>=0:@VM:0:@VM:-1:@VM:0:@VM:-1:@VM:0:@VM:0:@VM
  FORMATS<2> :=0:@VM:-1:@VM:-1:@VM:-1:@VM:0:@VM:-1:@VM:-1
  * NEXT.IND is the amount that all following lines will be indented
  FORMATS<3>=1:@VM:2:@VM:0:@VM:1:@VM:-1:@VM:1:@VM:1:@VM
  FORMATS<3> :=1:@VM:-1:@VM:-1:@VM:-1:@VM:1:@VM:0:@VM:0
  FORMATS<4>=DEF.INDENT
  *
  OPEN B.FILE TO FI ELSE PRINT 'Cannot open ':B.FILE ; RETURN
  READ REC FROM FI,B.ITEM ELSE PRINT "CANNOT READ ":B.FILE:" ":B.ITEM ; RETURN
  *WRITE REC ON FI,B.NAME:".BAK"
  SWAP CHAR(9) WITH SPACE(DEF.INDENT) IN REC
  *
  I = DCOUNT(REC,@AM)
  IF I < 2 THEN RETURN
  FOR F = 1 TO I
    PRINT STAR:
    L = REC<F> ; NEXT.LINE=REC<F+1>
    GOSUB FORMAT.LINE
    REC<F> = L
  NEXT F
  WRITE REC ON FI,B.ITEM
  PRINT STAR ; PRINT I:" lines of ":B.ITEM:" formatted"
  CLOSE FI
RETURN
*
FORMAT.LINE:
  * Format a line of code, figure out the indent level, as well as the indent level for the next line
  L=TRIM(L,' ','B')
  CONVERT TAB TO "" IN L
  FIRST.WORD = FIELD(L,SPC,1)
  LEN.FIRST.WORD = LEN(FIRST.WORD)
  LOCATE FIRST.WORD IN SPECIAL.CASES BY 'AL' SETTING SPECIAL ELSE SPECIAL = 0
  NUM.SPACES = COUNT(L,SPC) + 1
  LAST.WORD = FIELD(L,SPC,NUM.SPACES)
  NEXT.TO.LAST.WORD = FIELD(L,SPC,NUM.SPACES-1)
  THIS.IND = 0
  NEXT.IND = 0
  BEGIN CASE
    CASE L=""
      L="*" ;* Makes pasting code around easier with no blank lines
    CASE FIRST.WORD[LEN.FIRST.WORD,1] = COLON OR NUM(FIRST.WORD)
      * A label
      IND = 0
      LOCATE COLON IN FORMATS<1> SETTING POS ELSE POS = 0
      THIS.IND = FORMATS<2,POS>
      NEXT.IND = FORMATS<3,POS>
    CASE FIRST.WORD = "IF"
      LOCATE FIRST.WORD IN FORMATS<1> SETTING POS ELSE POS = 0
      IF LAST.WORD = "THEN" THEN
        THIS.IND = FORMATS<2,POS>
        NEXT.IND = FORMATS<3,POS>
      END
    CASE FIRST.WORD = "END"
      SECOND.WORD = FIELD(L,SPC,2)
      IF SECOND.WORD = "ELSE" THEN
        LOCATE "ELSE" IN FORMATS<1> SETTING POS ELSE POS = 0
        THIS.IND = -FORMATS<3,POS>
        NEXT.IND = FORMATS<2,POS>
      END ELSE
        IF SECOND.WORD = "CASE" THEN
          LOCATE "BEGIN" IN FORMATS<1> SETTING POS ELSE POS = 0
          THIS.IND = -FORMATS<3,POS>
          NEXT.IND = -FORMATS<3,POS>
        END ELSE
          LOCATE FIRST.WORD IN FORMATS<1> SETTING POS ELSE POS = 0
          THIS.IND = FORMATS<2,POS>
          NEXT.IND = FORMATS<3,POS>
        END
      END
    CASE SPECIAL
      * Find last word - skip until a space
      IF LAST.WORD = "ELSE" OR LAST.WORD = "THEN" THEN
        LOCATE LAST.WORD IN FORMATS<1> SETTING POS ELSE POS = 0
        THIS.IND = FORMATS<2,POS>
        NEXT.IND = FORMATS<3,POS>
      END
    CASE FIRST.WORD = "FOR" AND NEXT.TO.LAST.WORD = "NEXT"
      * FOR loop on one line means do nothing
    CASE FIRST.WORD = "RETURN" AND TRIM(NEXT.LINE) # "*"
      * RETURN without a blank line means do nothing
    CASE 1
      LOCATE FIRST.WORD IN FORMATS<1> SETTING POS ELSE POS = 0
      IF POS # 0 THEN
        THIS.IND = FORMATS<2,POS>
        NEXT.IND = FORMATS<3,POS>
      END
  END CASE
  L = SPACE((IND+THIS.IND)*DEF.INDENT):L
  *L = STR(TAB,IND+THIS.IND):L ;* In my misguided youth, tabs seemed cool
  IND = IND + NEXT.IND
RETURN
*
DIFF:
  FILE1=FIELD(ANS,' ',2)
  IF FILE1='' THEN CRT 'Enter file 1:': ; INPUT FILE1
  ID1=FIELD(ANS,' ',3)
  IF ID1='' THEN CRT 'Enter ID1   :': ; INPUT ID1
  FILE2=FIELD(ANS,' ',4)
  IF FILE2='' THEN CRT 'Enter file 2:': ; INPUT FILE2
  ID2=FIELD(ANS,' ',5)
  IF ID2='' THEN CRT 'Enter ID2   :': ; INPUT ID2
  CALL FILE.OPEN.OK(FILE1,FVAR1,OK)
  IF NOT(OK) THEN CRT "CAN'T OPEN ":FILE1 ; RETURN
  CALL FILE.OPEN.OK(FILE2,FVAR2,OK)
  IF NOT(OK) THEN CRT "CAN'T OPEN ":FILE1 ; RETURN
  CALL IDS.READ(REC1,FVAR1,ID1,0,0,BCI.ERROR) ; IF BCI.ERROR THEN REC1=''
  REC1.MAX=DCOUNT(REC1,@AM)
  CONVERT @VM TO '|' IN REC1
  CALL IDS.READ(REC2,FVAR2,ID2,0,0,BCI.ERROR) ; IF BCI.ERROR THEN REC2=''
  REC2.MAX=DCOUNT(REC2,@AM)
  CONVERT @VM TO '|' IN REC2
  IF REC2.MAX > REC1.MAX THEN MAX=REC2.MAX ELSE MAX=REC1.MAX
  COL.WIDTH=INT(TERM.WIDTH/2)-6 ; MASK='L#':COL.WIDTH
  DIFF=0
  FOR F=1 TO MAX
    CRT F'R#5':
    IF REC1<F> # REC2<F> THEN DIFF+=1; CRT '#': ELSE CRT '=':
    CRT REC1<F> MASK:'|':REC2<F> MASK
  NEXT F
  CRT DIFF:' differences found'
RETURN
*******************************************************************************
* KEYBOARD PROCESSING
*******************************************************************************
KEY.DEFAULTS:
  * Load default key bindings - this covers the basics, but you can add your own
  KEYMAP=''
  * Control characters
  KEYCOMMAND='{Backspace}'   ; KEYPRESS='^H' ; GOSUB ADD.KEYPRESS
  KEYCOMMAND='{Backspace}'   ; KEYPRESS='^?' ; GOSUB ADD.KEYPRESS
  KEYCOMMAND='{BackWord}'    ; KEYPRESS='^X' ; GOSUB ADD.KEYPRESS
  KEYCOMMAND='{Clear}'       ; KEYPRESS='^L' ; GOSUB ADD.KEYPRESS
  KEYCOMMAND='{Delete}'      ; KEYPRESS='^D' ; GOSUB ADD.KEYPRESS
  KEYCOMMAND='{DeleteLine}'  ; KEYPRESS='^K' ; GOSUB ADD.KEYPRESS
  KEYCOMMAND='{DeleteWord}'  ; KEYPRESS='^W' ; GOSUB ADD.KEYPRESS
  KEYCOMMAND='{Down}'        ; KEYPRESS='^N' ; GOSUB ADD.KEYPRESS
  KEYCOMMAND='{End}'         ; KEYPRESS='^E' ; GOSUB ADD.KEYPRESS
  KEYCOMMAND='{Enter}'       ; KEYPRESS='^M' ; GOSUB ADD.KEYPRESS
  KEYCOMMAND='{ForwardWord}' ; KEYPRESS='^I' ; GOSUB ADD.KEYPRESS
  KEYCOMMAND='{Home}'        ; KEYPRESS='^A' ; GOSUB ADD.KEYPRESS
  KEYCOMMAND='{Left}'        ; KEYPRESS='^B' ; GOSUB ADD.KEYPRESS
  KEYCOMMAND='{PgDown}'      ; KEYPRESS='^V' ; GOSUB ADD.KEYPRESS
  KEYCOMMAND='{PgUp}'        ; KEYPRESS='^U' ; GOSUB ADD.KEYPRESS
  KEYCOMMAND='{Quit}'        ; KEYPRESS='^G' ; GOSUB ADD.KEYPRESS
  KEYCOMMAND='{Quit}'        ; KEYPRESS='ESC'; GOSUB ADD.KEYPRESS
  KEYCOMMAND='{Right}'       ; KEYPRESS='^F' ; GOSUB ADD.KEYPRESS
  KEYCOMMAND='{Search}'      ; KEYPRESS='^R' ; GOSUB ADD.KEYPRESS
  KEYCOMMAND='{Up}'          ; KEYPRESS='^P' ; GOSUB ADD.KEYPRESS
  * Putty-compatible keys
  KEYCOMMAND='{BackWord}'    ; KEYPRESS='ESC[Z'     ; GOSUB ADD.KEYPRESS
  KEYCOMMAND='{BackWord}'    ; KEYPRESS='ESCESC[D'  ; GOSUB ADD.KEYPRESS
  KEYCOMMAND='{Clear}'       ; KEYPRESS='ESCESC[1~' ; GOSUB ADD.KEYPRESS
  KEYCOMMAND='{Delete}'      ; KEYPRESS='ESC[3~'    ; GOSUB ADD.KEYPRESS
  KEYCOMMAND='{DeleteLine}'  ; KEYPRESS='ESCESC[4~' ; GOSUB ADD.KEYPRESS
  KEYCOMMAND='{DeleteWord}'  ; KEYPRESS='ESCESC[3~' ; GOSUB ADD.KEYPRESS
  KEYCOMMAND='{Down}'        ; KEYPRESS='ESC[B'     ; GOSUB ADD.KEYPRESS
  KEYCOMMAND='{End}'         ; KEYPRESS='ESC[4~'    ; GOSUB ADD.KEYPRESS
  KEYCOMMAND='{ForwardWord}' ; KEYPRESS='ESCESC[C'  ; GOSUB ADD.KEYPRESS
  KEYCOMMAND='{Home}'        ; KEYPRESS='ESC[1~'    ; GOSUB ADD.KEYPRESS
  KEYCOMMAND='{Left}'        ; KEYPRESS='ESC[D'     ; GOSUB ADD.KEYPRESS
  KEYCOMMAND='{PgDown}'      ; KEYPRESS='ESC[6~'    ; GOSUB ADD.KEYPRESS
  KEYCOMMAND='{PgUp}'        ; KEYPRESS='ESC[5~'    ; GOSUB ADD.KEYPRESS
  KEYCOMMAND='{Right}'       ; KEYPRESS='ESC[C'     ; GOSUB ADD.KEYPRESS
  KEYCOMMAND='{Up}'          ; KEYPRESS='ESC[A'     ; GOSUB ADD.KEYPRESS
  * Xterm-compatible keys
  KEYCOMMAND='{Down}'        ; KEYPRESS='ESCOB'     ; GOSUB ADD.KEYPRESS
  KEYCOMMAND='{End}'         ; KEYPRESS='ESC[F'     ; GOSUB ADD.KEYPRESS
  KEYCOMMAND='{Home}'        ; KEYPRESS='ESC[H'     ; GOSUB ADD.KEYPRESS
  KEYCOMMAND='{Left}'        ; KEYPRESS='ESCOD'     ; GOSUB ADD.KEYPRESS
  KEYCOMMAND='{Right}'       ; KEYPRESS='ESCOC'     ; GOSUB ADD.KEYPRESS
  KEYCOMMAND='{Up}'          ; KEYPRESS='ESCOA'     ; GOSUB ADD.KEYPRESS
  *
  WRITE KEYMAP ON HOME.F, KEYMAP.ITEM
RETURN
*
LIST.KEYS:
  * List all the key bindings
  FOR K=1 TO DCOUNT(KEYCOMMLIST<1>,@VM)
    KEYCOMMAND=KEYCOMMLIST<1,K>
    KEYCOMMANDDESC=KEYCOMMLIST<2,K>
    GOSUB SHOW.KEY
  NEXT K
RETURN
*
TRAIN:
  * Add your own custom key bindings
  IF KEYMAP='' THEN GOSUB KEY.DEFAULTS
  *
  CRT 'Adding custom key bindings to your keymap'
  CRT 'For each possible command, the current setting will be displayed'
  CRT 'and you can press any key you would like to be mapped to that command.'
  CRT 'Some settings are built-in, such as Ctrl-P for previous, or Ctrl-U for page up'
  CRT ''
  CRT 'You can create multiple mapping for the same commands, like Shift-tab or'
  CRT 'Alt-left arrow to go back a word. Press ENTER when you are done with a command'
  *
  FOR K=1 TO DCOUNT(KEYCOMMLIST<1>,@VM)
    KEYCOMMAND=KEYCOMMLIST<1,K>
    KEYCOMMANDDESC=KEYCOMMLIST<2,K>
    GOSUB SET.KEY
  NEXT K
  *
  WRITE KEYMAP ON HOME.F, KEYMAP.ITEM
RETURN
*
SHOW.KEY:
  * Show the current key binding for KEYCOMMAND
  FOR J=1 TO DCOUNT(KEYMAP<1>,@VM)
    IF KEYMAP<2,J>=KEYCOMMAND THEN
      CRT KEYCOMMAND 'L#15':' ':KEYCOMMANDDESC'L#50':' ':KEYMAP<1,J>
    END
  NEXT J
RETURN
*
SET.KEY:
  * Set a key binding for KEYCOMMAND
  CRT STR('-',80)
  GOSUB SHOW.KEY
  LOOP
    CRT 'Enter to skip or press the key for ':KEYCOMMAND:':'
    KEYPRESS=''
    LOOP
      CH=IN()
      ASC.CH = SEQ(CH)
      IF ASC.CH=13 THEN RETURN
      IF ASC.CH<27 THEN CH='^':CHAR(SEQ('A')-1+ASC.CH)
      IF ASC.CH=27 THEN CH='ESC'
      IF ASC.CH=127 THEN CH='^?'
      CRT CH
      KEYPRESS:=CH
    UNTIL SYSTEM(14) = 0 DO
    REPEAT
    GOSUB ADD.KEYPRESS
  REPEAT
RETURN
*
ADD.KEYPRESS:
  * Add a new key binding to an existing KEYCOMMAND
  LOCATE KEYPRESS IN KEYMAP<1> BY 'AL' SETTING POS THEN
    CRT 'Duplicate key detected! ':KEYPRESS:' mapped to ':KEYMAP<2,POS>
  END ELSE
    INS KEYPRESS BEFORE KEYMAP<1,POS>
    INS KEYCOMMAND BEFORE KEYMAP<2,POS>
  END
RETURN
*
KEYS:
  * Show the ASCII key values, useful for setting up key bindings
  LOOP
    CRT 'PRESS A KEY, / to exit:':
    CH=IN()
    ASC.CH = SEQ(CH)
    IF ASC.CH >= 32 AND ASC.CH < 127 THEN CRT CH:'=': ELSE CRT ' =':
    CRT ASC.CH
  UNTIL CH='/' DO
  REPEAT
RETURN
*
GET.LINE:
  * Get a line of input, with some basic editing
  * SUBROUTINE GET.LINE(X,LEN,DISP.LEN,XXDATA,RTN)
  * X           = X POS
  * LEN         = MAX ALLOWED LENGTH
  * DISP.LEN    = MAX DISPLAYED LEN
  * XXDATA      = ON INPUT  VARIABLE XXDATA
  *             = ON OUTPUT RETURNED STRING
  * RTN         = SEQ(CHAR PRESSED TO EXIT)
  * -----------------
  * Important globals
  * CP          = Cursor Position, Y coordinate on the screen 0 -> DISP.LEN
  * CH.PTR      = Pointer into string being edited            1 -> LEN
  * POS         = Pointer to first char currently displayed   1 -> LEN
  * ASC.CH      = The numeric value of the key just entered
  *
  IF NOT(GET.LINE.FLAG) THEN
    PRINT @(X):;INPUT ENTRY
    RTN = RET
    RETURN
  END
  *
  ECHO OFF
  P1=1 ; P2=20
  SEARCH.FOR=''
  GOSUB GET.LINE.INIT
  *
  LOOP
    EXIT.FLAG=FALSE
    CURR.LEN = LEN(XXDATA)
    CRT @(X+CP):
    BUFFER=''
    LOOP
      CH=IN()
      ASC.CH = SEQ(CH)
      IF ASC.CH<27 THEN CH='^':CHAR(SEQ('A')-1+ASC.CH)
      IF ASC.CH=27 THEN CH='ESC'
      IF ASC.CH=127 THEN CH='^?'
      BUFFER:=CH
    UNTIL SYSTEM(14) = 0 DO
    REPEAT
    *
    IF LEN(BUFFER)=1 THEN
      * Special case single keystroke to keep character entry fast
      KEYCOMMAND=''
      CH=BUFFER
      GOSUB PROCESS.KEYPRESS
    END ELSE
      * We may have multiple "things" loaded in the buffer, attempt to find the longest sequence
      * E.g. ESC[AESC[AESC[1~BAStart = Up Up Down Down Left Right Left Right B A Start
      L=LEN(BUFFER)
      LOOP
        KEYPRESS=BUFFER[1,L]
        LOCATE KEYPRESS IN KEYMAP<1> BY 'AL' SETTING COMMAND.POS THEN
          * We found a command, process it, remove from list and start over
          KEYCOMMAND=KEYMAP<2,COMMAND.POS>
          GOSUB PROCESS.KEYPRESS
          BUFFER=BUFFER[L+1,LEN(BUFFER)]
          L=LEN(BUFFER)
        END ELSE
          L-=1
        END
        IF L=0 THEN
          * Just regular or unmatched keypresses left, e.g. LISTA^M
          FOR L=1 TO LEN(BUFFER)
            KEYCOMMAND=''
            CH=BUFFER[L,1]
            IF CH='^' THEN
              KEYPRESS=CH:BUFFER[L+1,1]
              LOCATE KEYPRESS IN KEYMAP<1> BY 'AL' SETTING COMMAND.POS THEN
                KEYCOMMAND=KEYMAP<2,COMMAND.POS>
                L+=1
              END
            END
            GOSUB PROCESS.KEYPRESS
          NEXT L
          EXIT
        END
      REPEAT
    END
  UNTIL EXIT.FLAG DO
  REPEAT
  IF XXDATA[CURR.LEN,1] = SPC THEN XXDATA = XXDATA[1,CURR.LEN-1]
  ECHO ON ; PRINT BASE:XXDATA MASK
  ENTRY=XXDATA
RETURN
    *
PROCESS.KEYPRESS:
  * Process a single keypress, could be a character added to a command, or could be an editing command
  BEGIN CASE
    CASE KEYCOMMAND=''
      GOSUB ORD
    CASE KEYCOMMAND='{Home}'
      GOSUB GO.BEGIN
    CASE KEYCOMMAND='{Left}'
      GOSUB LEFT
    CASE KEYCOMMAND='{Delete}'
      GOSUB DEL
    CASE KEYCOMMAND='{End}'
      GOSUB GO.END
    CASE KEYCOMMAND='{Right}'
      GOSUB RIGHT
    CASE KEYCOMMAND='{Quit}'
      XXDATA = ''
      EXIT.FLAG=TRUE
      RTN=13
    CASE KEYCOMMAND='{Backspace}'
      GOSUB BACK
    CASE KEYCOMMAND='{DeleteLine}'
      GOSUB DEL.TO.END
    CASE KEYCOMMAND='{Clear}'
      PRINT @(-1):
      XXDATA = ''
      EXIT.FLAG=TRUE
      RTN=13
    CASE KEYCOMMAND='{Enter}'
      * Special case for .R and .X, which are treated as editing commands, not stack commands
      IF UPCASE(XXDATA[1,2])='.R' OR UPCASE(XXDATA[1,2])='.X' THEN
        LINE.NUM=TRIM(XXDATA[3,CURR.LEN])
        IF NUM(LINE.NUM) THEN
          ENTRY = STACK<LINE.NUM,4>
          GOSUB GET.LINE.INIT
        END ELSE
          CRT BELL:
        END
      END ELSE
        EXIT.FLAG = TRUE
        RTN=13
      END
    CASE KEYCOMMAND='{Down}'
      GOSUB DOWN.KEY
    CASE KEYCOMMAND='{Up}'
      GOSUB UP.KEY
    CASE KEYCOMMAND='{Search}'
      GOSUB SEARCH.KEY
    CASE KEYCOMMAND='{PgUp}'
      GOSUB PAGE.UP
    CASE KEYCOMMAND='{PgDown}'
      GOSUB PAGE.DOWN
    CASE KEYCOMMAND='{DeleteWord}'
      GOSUB DELETE.WORD
    CASE KEYCOMMAND='{BackWord}'
      GOSUB BACK.WORD
    CASE KEYCOMMAND='{ForwardWord}'
      GOSUB FORWARD.WORD
  END CASE
RETURN
*
GET.LINE.INIT:
  * Initialize variables for GET.LINE
  XXDATA = ENTRY
  TEMP.XXDATA = XXDATA
  BASE = @(X):EOS ; MASK = 'L#':DISP.LEN
  PRINT BASE:
  CURR.LEN = LEN(XXDATA)
  GOSUB GO.END
  RTN=''
RETURN
*
UP.KEY:
  * Up arrow pressed
  LINE.NUM+=1
  ENTRY=STACK<LINE.NUM,4>
  GOSUB GET.LINE.INIT
RETURN
*
DOWN.KEY:
  * Down arrow pressed
  LINE.NUM-=1
  IF LINE.NUM<0 THEN
    LINE.NUM=0
    ENTRY=''
  END ELSE
    ENTRY=STACK<LINE.NUM,4>
  END
  GOSUB GET.LINE.INIT
RETURN
*
PAGE.UP:
  * Page up pressed
  GOSUB LIST.STACK
  ENTRY=''
  GOSUB GET.LINE.INIT
  CRT BON:PROMPT.DISP:BOFF:
  P2 = P2 + 20
  P1 = P1 + 20
  IF P2 > MAX.STACK THEN P2 = MAX.STACK
  IF P1 > MAX.STACK-20 THEN P1 = MAX.STACK-20
RETURN
*
PAGE.DOWN:
  * Page down pressed
  GOSUB LIST.STACK
  ENTRY=''
  GOSUB GET.LINE.INIT
  CRT BON:PROMPT.DISP:BOFF:
  P2 = P2 - 20
  P1 = P1 - 20
  IF P2 < 20 THEN P2=20
  IF P1 < 1 THEN P1=1
RETURN
*
SEARCH.KEY:
  * Search the stack for a string, hit ^R to repeat search from current position
  IF SEARCH.FOR='' THEN
    ECHO ON
    CRT BASE:'Search for:':
    INPUT SEARCH.FOR:
    SEARCH.FOR=UPCASE(SEARCH.FOR)
    ECHO OFF
  END
  * Search the stack for a string
  FOUND = FALSE
  FOR F = LINE.NUM+1 TO MAX.STACK UNTIL FOUND OR STACK<F> = ''
    IF INDEX(UPCASE(STACK<F,4>),SEARCH.FOR,1) # 0 THEN FOUND = TRUE
  NEXT F
  IF FOUND THEN
    LINE.NUM=F-1
    ENTRY=STACK<LINE.NUM,4>
    GOSUB GET.LINE.INIT
  END ELSE
    PRINT BELL:
  END
RETURN
*
ORD:
  * Ordinary key pressed, add to string, shift display if necessary
  ASC.CH = SEQ(CH)
  IF ASC.CH < 32 OR ASC.CH > 126 THEN CH='~' ;* If a non-printable character, display as a tilde
  IF CH.PTR # LEN+1 THEN
    IF CURR.LEN = LEN THEN
      PRINT BELL:
      GOTO SKIP1
    END ELSE
      XXDATA = XXDATA[1,CH.PTR-1]:CH:XXDATA[CH.PTR,CURR.LEN]
    END
    CH.PTR = CH.PTR + 1
    IF CP # DISP.LEN THEN
      PRINT @(X+CP):CH:XXDATA[CH.PTR,DISP.LEN-CP-1]:
      CP = CP + 1
    END ELSE
      POS = POS + 1
      PRINT BASE:XXDATA[POS,DISP.LEN] MASK:
    END
  END ELSE
    PRINT BELL:
  END
SKIP1:
RETURN
*
RIGHT:
  * There are 3 situations here -
  * 1 We're pressing the right arrow thru existing text       (CH.PTR = CURR.LEN)
  * 2 We've typed text and are at the end when we press right (CH.PTR > CURR.LEN)
  * 3 We're in the middle of text, pressing the right arrow   (CH.PTR < CURR.LEN)
  IF CH.PTR < LEN THEN
    IF CH.PTR > CURR.LEN THEN PRINT BELL: ; GOTO SKIP2
    IF CH.PTR = CURR.LEN THEN
      * If the last char is not a space make it one
      IF XXDATA[CURR.LEN,1] # SPC THEN
        XXDATA = XXDATA:SPC
        IF CP # DISP.LEN THEN PRINT @(X+CP+1):SPC:
        CURR.LEN = CURR.LEN + 1
      END ELSE
        PRINT BELL:
        GOTO SKIP2
      END
    END
    CH.PTR = CH.PTR + 1
    IF CP # DISP.LEN THEN
      * We're not at the end of display so just move the cursor
      CP = CP + 1
    END ELSE
      * We are at the end of the display so leave cursor where
      * it is and scroll through line
      POS = POS + 1
      PRINT BASE:XXDATA[POS,DISP.LEN] MASK:
    END
  END ELSE
    PRINT BELL:
  END
SKIP2:
RETURN
*
FORWARD.WORD:
  * Jump forward a word, words are defined as anything between spaces
  IF CH.PTR >= CURR.LEN THEN
    PRINT BELL:
  END ELSE
    LOOP
      CH.PTR = CH.PTR + 1
      CP = CP + 1
    UNTIL XXDATA[CH.PTR,1] = SPC OR CH.PTR = CURR.LEN DO
    REPEAT
    IF CH.PTR # CURR.LEN THEN
      LOOP
        CH.PTR = CH.PTR + 1
        CP = CP + 1
      UNTIL XXDATA[CH.PTR,1] # SPC OR CH.PTR = CURR.LEN DO
      REPEAT
    END
    IF CP > DISP.LEN THEN
      CP = DISP.LEN
      POS = CH.PTR - DISP.LEN
      PRINT BASE:XXDATA[POS,DISP.LEN] MASK:
    END
  END
RETURN
*
LEFT:
  * If we're not at the start of data, move left
  IF CH.PTR # 1 THEN
    CH.PTR = CH.PTR - 1
    IF CP # 0 THEN
      * We're not at the start of the display so just move the cursor
      CP = CP - 1
    END ELSE
      * We are at the start of the display so leave cursor and scroll
      POS = POS - 1
      PRINT BASE:XXDATA[POS,DISP.LEN] MASK:
    END
  END ELSE
    PRINT BELL:
  END
RETURN
*
DEL:
  * Delete the character at the cursor and redisplay from this point
  XXDATA = XXDATA[1,CH.PTR-1]:XXDATA[CH.PTR+1,CURR.LEN]
  CURR.LEN = CURR.LEN - 1
  PRINT BASE:XXDATA[POS,DISP.LEN] MASK:
RETURN
*
BACK:
  * Backspace key pressed
  IF CH.PTR # 1 THEN
    CH.PTR = CH.PTR - 1
    XXDATA = XXDATA[1,CH.PTR-1]:XXDATA[CH.PTR+1,CURR.LEN]
    CURR.LEN = CURR.LEN - 1
    IF CP # 0 THEN
      CP = CP - 1
    END ELSE
      POS = POS - 1
    END
    PRINT BASE:XXDATA[POS,DISP.LEN] MASK:
  END ELSE
    PRINT BELL:
  END
RETURN
*
BACK.WORD:
  * Shift tab pressed - go back a word
  IF CH.PTR = 1 THEN
    PRINT BELL:
  END ELSE
    * 2 situations - either we're in a word already or
    * we're at the start of a word
    * If in a word - loop to the start of the word
    * otherwise skip spaces, and then move to start of word
    IF XXDATA[CH.PTR-1,1] # SPC THEN
      LOOP
      UNTIL XXDATA[CH.PTR-1,1] = SPC OR CH.PTR = 1 DO
        CH.PTR = CH.PTR - 1
        CP = CP - 1
      REPEAT
    END ELSE
      * Skip spaces
      LOOP
      UNTIL XXDATA[CH.PTR-1,1] # SPC OR CH.PTR = 1 DO
        CH.PTR = CH.PTR - 1
        CP = CP - 1
      REPEAT
      IF CH.PTR > 1 THEN
        * At word end - move to start of word
        LOOP
        UNTIL XXDATA[CH.PTR-1,1] = SPC OR CH.PTR = 1 DO
          CH.PTR = CH.PTR - 1
          CP = CP - 1
        REPEAT
      END
    END
    IF CP < 0 THEN
      CP = 0
      POS = CH.PTR
      PRINT BASE:XXDATA[POS,DISP.LEN] MASK:
    END
  END
RETURN
*
DEL.TO.END:
  * Delete from cursor to end of line
  IF CH.PTR = 1 THEN
    XXDATA = ''
    CP = 0
    POS = 1
  END ELSE
    XXDATA = XXDATA[1,CH.PTR-1]
  END
  CURR.LEN = LEN(XXDATA)
  PRINT BASE:XXDATA[POS,DISP.LEN] MASK:
RETURN
*
DELETE.WORD:
  * Delete to space at right of cursor
  IF CH.PTR >= CURR.LEN THEN
    PRINT BELL:
  END ELSE
    C = CH.PTR
    LOOP
      C = C + 1
    UNTIL XXDATA[C,1] = SPC OR C = CURR.LEN DO
    REPEAT
    XXDATA = XXDATA[1,CH.PTR-1]:XXDATA[C+1,CURR.LEN]
    CURR.LEN = CURR.LEN - C + CH.PTR - 1
    PRINT BASE:XXDATA[POS,DISP.LEN] MASK:
  END
RETURN
*
GO.BEGIN:
  * Go to the start of data and redisplay
  CP = 0
  CH.PTR = 1
  POS = 1
  PRINT BASE:XXDATA MASK:
RETURN
*
GO.END:
  * Move to the end of data and redisplay
  IF XXDATA[CURR.LEN,1] # SPC THEN
    XXDATA = XXDATA:SPC
    CURR.LEN = CURR.LEN + 1
  END
  IF CURR.LEN < DISP.LEN THEN
    CP = CURR.LEN - 1
    POS = 1
  END ELSE
    CP = DISP.LEN - 1
    POS = CURR.LEN - DISP.LEN + 1
  END
  CH.PTR = CURR.LEN
  PRINT BASE:XXDATA[POS,DISP.LEN] MASK:
RETURN
*******************************************************************************
* INFOLEASE UTILITIES
*******************************************************************************
IL10.NED:
  * Simulate the ED command with a record read from SQL server
  IF IL.MAJOR.VER#10 THEN PRINT 'Only works in IL10' ; RETURN
  OPEN '_HOLD_' TO F.HOLD ELSE STOP 201,'_HOLD_'
  FILE.NAME=FIELD(ANS,' ',2)
  K.FILE=FIELD(ANS,' ',3)
  CALL FILE.OPEN.OK(FILE.NAME, F.FILE, FILE.OPEN.OK)
  IF NOT(FILE.OPEN.OK) THEN CRT 'Cannot open ':FILE.NAME ; RETURN
  CALL IDS.READ(R.FILE, F.FILE,  K.FILE, 0, 0, BCI.ERROR)
  IF BCI.ERROR # '' THEN PRINT BCI.ERROR ; R.FILE=''
  R.ORIG=R.FILE
  *
  LOOP
    PRINT DCOUNT(R.FILE,@AM):' fields in record'
    PRINT 'Enter D)elete, E)dit, L)ist, S)ave or Q)uit:':
    INPUT OPT
    BEGIN CASE
      CASE OPT='D'
        CRT 'Are you *really* sure (YES/N):':
        INPUT YORN
        IF YORN = 'YES' THEN
          CALL IDS.DELETE(F.FILE, K.FILE, 0, 0)
          CRT FILE.NAME:' ':K.FILE:' deleted'
          LOG='NED/DELETE'
          LOG<2>=FILE.NAME
          LOG<3>=K.FILE
          R.FILE=''
          RETURN
        END
      CASE OPT='L'
        R.TMP=R.FILE ;* In case we've edited, VIEW.RECORD will read it in again
        GOSUB VIEW.RECORD
        R.FILE=R.TMP
      CASE OPT='S'
        CALL IDS.WRITE(R.FILE, F.FILE, K.FILE, 0, 0)
        PRINT 'Saved.  Press ENTER to continue:':
        LOG='NED/SAVE'
        LOG<2>=FILE.NAME
        LOG<3>=K.FILE
        R.ORIG=R.FILE
        INPUT AAA
      CASE OPT='E'
        R=R.FILE
        SWAP CHAR(13):CHAR(10) WITH '||' IN R
        TMP.FILE=K.FILE
        CONVERT '*' TO '#' IN TMP.FILE
        WRITE R ON F.HOLD, TMP.FILE
        EXECUTE \ED _HOLD_ \:TMP.FILE
        READ R FROM F.HOLD, TMP.FILE ELSE R=''
        SWAP '||' WITH CHAR(13):CHAR(10) IN R
        IF R # R.FILE THEN
          PRINT 'Record changed, use S to save'
          R.FILE=R
        END
        DELETE F.HOLD, TMP.FILE
      CASE OPT='Q'
        IF R.FILE#R.ORIG THEN
          PRINT 'Record changed, are you sure (Y/N):':
          INPUT YORN
          IF YORN # 'Y' THEN OPT=''
        END
    END CASE
  UNTIL OPT='Q' DO
  REPEAT
RETURN
*
GET.BPI:
  * Given a BPI name, get the BPI record
  BPI.REC=''
  BPI.R=''
  OPEN 'DATABASE.FILES,IL' TO IL ELSE CRT 'Cannot open DATABASE.FILES,IL' ; RETURN
  OPEN 'IL.BPI' TO IL.BPI ELSE CRT 'Cannot open IL.BPI' ; RETURN
  * Param 2 can be a BPI or a FILENAME
  READ BPI.R FROM IL.BPI, BPI ELSE
    READV IL.MSG FROM IL, BPI, 14 THEN
      * Sample: Attached to FLOAT.INCOME bpi.
      N=DCOUNT(IL.MSG,' ')
      BPI=FIELD(IL.MSG,' ',N-1)
      READ BPI.R FROM IL.BPI, BPI ELSE PRINT 'Cannot get BPI name' ; RETURN
    END ELSE
      PRINT 'Cannot read DATABASE.FILES,IL',BPI ; RETURN
    END
  END
  *
  FOR F=1 TO DCOUNT(BPI.R,@AM)
    L=BPI.R<F>
    IF L[1,6] = 'EQUATE' THEN
      FLD.NUM=FIELD(FIELD(L,'(',2),')',1)
      BPI.REC<FLD.NUM>=FIELD(BPI.R<F>[8,99],' ',1)
    END
  NEXT F
  *
  CLOSE IL
  CLOSE IL.BPI
RETURN
*
BPI:
  * Edit a BPI record
  IF IL.MAJOR.VER='' THEN PRINT 'Only works in IL' ; RETURN
  BPI=FIELD(ANS,' ',2)
  IF BPI='' THEN PRINT 'Usage: BPI <name of infolease file|name of BPI>' ; RETURN
  GOSUB GET.BPI
  IF BPI.REC='' THEN RETURN
  EXEC.LINE=\AE IL.BPI \:BPI
  GOSUB EXEC.SUB
RETURN
*
GET.FILE.METADATA:
  * Given FILE.NAME, get column names and types in FILE.META
  TMP.FILE.NAME=FILE.NAME
  FILE.META='' ; BPI='' ; TABLE.NAME=''
  IF FILE.NAME='PARAMETER' THEN
    * Need to figure out based on record key, not just FILE.NAME
    GOSUB GET.PARAMETER.BPI
    IF BPI = '' THEN RETURN
    IF IL.MAJOR.VER=9 THEN FILE.NAME=BPI ELSE FILE.NAME=TABLE.NAME
  END
  *
  IF IL.MAJOR.VER=9 THEN
    GOSUB GET.FILE.METADATA.IL9
  END ELSE
    GOSUB GET.FILE.METADATA.IL10
  END
  FILE.NAME=TMP.FILE.NAME
  CRT 'BPI=':BPI:', TABLE NAME=':TABLE.NAME
RETURN
*
GET.PARAMETER.BPI:
  * Figure out the BPI for a PARAMETER record, based on the key structure
  TMP.ANS=ANS
  ANS='/NOLIST' ;* Signal LIST.PARAM to just build the P array, don't list anything
  GOSUB LIST.PARAM
  ANS=TMP.ANS
  *
  BPI=''
  FOR I=1 TO DCOUNT(P<1>,@VM)
    KEY=P<1,I>
    BEGIN CASE
      CASE INT(R.ID)
        BPI='LS.ADDRESS' ; TABLE.NAME='LS_ADDRESS_NF' ; EXIT
      CASE R.ID=KEY ;* 00*00
        BPI=P<4,I> ; TABLE.NAME=P<3,I> ; EXIT
      CASE KEY[1,1]='*'
        IF FIELD(R.ID,'*',2) = FIELD(KEY,'*',2) THEN BPI=P<4,I> ; TABLE.NAME=P<3,I> ; EXIT
      CASE INDEX(KEY,'*',1) > 1
        IF FIELD(R.ID,'*',1):'!' = FIELD(KEY,'*',1):'!' THEN BPI=P<4,I> ; TABLE.NAME=P<3,I> ; EXIT
    END CASE
  NEXT I
RETURN
*
GET.FILE.METADATA.IL9:
  * Get metadata for a file in IL9 from REV.ATB.LOG
  BPI=FILE.NAME
  GOSUB GET.BPI
  FOR I=1 TO DCOUNT(BPI.REC,@AM)
    ATB=BPI.REC<I>
    FILE.META<1,I>=ATB
    READ AREC FROM REV.ATB.LOG,ATB ELSE AREC=''
    FILE.META<2,I>=AREC<14> ;* S, MV, MS
    FILE.META<3,I>=AREC<10> ;* Mask, E.g. MR2, D4/, MTS
  NEXT I
  TABLE.NAME=TMP.FILE.NAME
RETURN
*
GET.FILE.METADATA.IL10:
  * Get metadata for a file in IL10 from METADATA_FIELDS
  SELECT.COMMAND = \SELECT\
  SELECT.COMMAND := \ STRING_POS, FIELD_NAME, VALUE_TYPE, FIELD_TYPE, TABLE_NAME, BPI\
  SELECT.COMMAND := \ FROM METADATA_FIELDS WHERE FILE_NAME = '\:FILE.NAME:\' OR BPI = '\:BPI:\'\
  SELECT.COMMAND := \ ORDER BY STRING_POS\
  CALL IDS.EXECUTE.ANSI.SQL(SELECT.COMMAND,'','','',MF.REC)
  BPI=MF.REC<1,6> ; TABLE.NAME=MF.REC<1,5>
  FOR I=1 TO DCOUNT(MF.REC,@AM)
    STRING_POS=MF.REC<I,1>
    FILE.META<1,STRING_POS>=MF.REC<I,2>
    FILE.META<2,STRING_POS>=MF.REC<I,3>
    BEGIN CASE
      CASE MF.REC<I,4>='DATE'
        FILE.META<3,STRING_POS>='D4/'
      CASE MF.REC<I,4>='DECIMAL'
        FILE.META<3,STRING_POS>='MD2'
      CASE MF.REC<I,4>='INTEGER'
        FILE.META<3,STRING_POS>='MD0'
      CASE MF.REC<I,4>='MONEY'
        FILE.META<3,STRING_POS>='MD2'
      CASE MF.REC<I,4>='TIME'
        FILE.META<3,STRING_POS>='MTS'
      CASE 1
        FILE.META<3,STRING_POS>='' ;* Leave all the rest alone
    END CASE
  NEXT I
RETURN
*
VIEW.RECORD:
  * View a record in a file, showing field names and values
  IF IL.MAJOR.VER='' THEN PRINT 'Only works in IL' ; RETURN
  FILE.NAME=FIELD(ANS,' ',2)
  CALL FILE.OPEN.OK(FILE.NAME, F.FILE, FILE.OPEN.OK)
  IF NOT(FILE.OPEN.OK) THEN CRT 'Error opening ':FILE.NAME ; RETURN
  R.ID=FIELD(ANS,' ',3)
  GOSUB GET.FILE.METADATA
  MAT RECORD.DATA='' ; RECORDS='' ; FLD=3 ; REC.NO=1 ; MAX.REC.COUNT=0
  LOOP
    R.ID=FIELD(ANS,' ',FLD)
  UNTIL R.ID='' DO
    RECORDS<-1>=R.ID
    IF IL.MAJOR.VER=9 THEN
      READ R1 FROM F.FILE, R.ID ELSE CRT 'Cannot read ':FILE.NAME:' ':R.ID ; RETURN
    END ELSE
      CALL IDS.READ(R1, F.FILE, R.ID, 0, 0, BCI.ERROR)
      IF BCI.ERROR # '' THEN PRINT BCI.ERROR:' ':R.ID ; RETURN
    END
    RECORD.DATA(REC.NO)=R1
    MAX.REC.NO=REC.NO
    REC.COUNT=DCOUNT(R1,@AM)
    IF REC.COUNT>MAX.REC.COUNT THEN MAX.REC.COUNT=REC.COUNT
    REC.NO+=1
    IF REC.NO=11 THEN CRT 'Too many records' ; RETURN
    FLD+=1
  REPEAT
  COL.WID=INT((TERM.WIDTH-25)/MAX.REC.NO)-1
  MSK='L#':COL.WID
  *
  FOR I=1 TO MAX.REC.COUNT
    ATB=FILE.META<1,I> ; TYPE=FILE.META<3,I>
    CRT I 'R#3':') ':
    IF FILE.META # '' THEN CRT ATB'L#20':
    FOR REC.NO=1 TO MAX.REC.NO
      VALUE=RECORD.DATA(REC.NO)<I>
      GOSUB VIEW.RECORD.ATB
      CRT '|':VALUE[1,COL.WID]:SPACE(COL.WID-LEN(VALUE)):
    NEXT REC.NO
    CRT ''
  NEXT I
RETURN
*
VIEW.RECORD.ATB:
  * Format a field value for VIEW.RECORD
  IF VALUE='' THEN RETURN
  FOR M=1 TO DCOUNT(VALUE<1>,@VM)
    BEGIN CASE
      CASE TYPE='D4/'
        VALUE<1,M>=OCONV(VALUE<1,M>,'D4-YMD')
      CASE TYPE[1,3]='MD2'
        VALUE<1,M>=OCONV(VALUE<1,M>,'MR2,')
    END CASE
  NEXT M
  CONVERT @VM TO '|' IN VALUE
RETURN
*
FIND.MENU:
  * Find a menu or program in the menu system, breadth first search
  IF IL.MAJOR.VER='' THEN PRINT 'Only works in IL' ; RETURN
  OPEN "DB.MENUS" TO MENU.F ELSE CRT 'Cannot open DB.MENUS' ; RETURN
  STR=FIELD(ANS,' ',2)
  IF STR='' THEN
    PRINT "Enter menu or program to search for : ": ; INPUT STR
    IF STR="" OR STR="/" THEN RETURN
  END
  STR = OCONV(STR,"MCU")
  MENU.LIST=''
  MENU.LIST<1>=1
  MENU.LIST<2>=0
  MENU.CTR=1
  LOOP
    MENU=MENU.LIST<1,MENU.CTR>
    PATH=MENU.LIST<2,MENU.CTR>
    IF MENU='' THEN EXIT
    GOSUB SEARCH.MENU
    MENU.CTR+=1
  REPEAT
  CLOSE MENU.F
RETURN
*
SEARCH.MENU:
  * Search a menu for a string, add any menus found to MENU.LIST so they are searched too
  READ R FROM MENU.F, MENU THEN
    TITLES = OCONVS(R<2>,"MCU") ; PROGS  = OCONVS(R<3>,"MCU") ; FLAGS = R<4> ; TYPES = R<5>
    I = DCOUNT(PROGS,@VM)
    FOR F = 1 TO I
      IF INDEX(PROGS<1,F>,STR,1) # 0 OR INDEX(TITLES<1,F>,STR,1) # 0 THEN
        PRINT MENU"R#5":" ":TITLES<1,F>"L#27":"  ":TYPES<1,F>'L#1':" ":PROGS<1,F>"L#50":" ":PATH:',':F
      END
      IF FLAGS<1,F>='M' THEN MENU.LIST<1,-1>=PROGS<1,F> ; MENU.LIST<2,-1>=PATH:',':F
    NEXT F
  END
RETURN
*
CI:
  * CONTRACT INQUIRY, wrapper around CMAINT.00
  IF IL.MAJOR.VER='' THEN PRINT 'Only works in IL' ; RETURN
  GOSUB REMOVE.CONTROL.CHARS ;* Pasting from excel often brings in a CR or &nbsp
  CONTRACT=FIELD(ANS,' ',2)
  DATA 0
  DATA 0
  DATA 0
  DATA 0
  IF CONTRACT # '' THEN
    CONVERT '_' TO '-' IN CONTRACT
    CONVERT '.' TO '-' IN CONTRACT
    DATA FIELD(CONTRACT,'-',1)
    DATA FIELD(CONTRACT,'-',2,2)
  END
  EXEC.LINE=\CMAINT.00\ ; GOSUB EXEC.SUB
RETURN
*
CM:
  * CONTRACT MAINTENANCE, wrapper around CMAINT.00
  IF IL.MAJOR.VER='' THEN PRINT 'Only works in IL' ; RETURN
  GOSUB REMOVE.CONTROL.CHARS ;* Pasting from excel often brings in a CR or &nbsp
  CONTRACT=FIELD(ANS,' ',2)
  DATA 1
  DATA 0
  DATA 0
  DATA 0
  IF CONTRACT # '' THEN
    CONVERT '_' TO '-' IN CONTRACT
    CONVERT '.' TO '-' IN CONTRACT
    DATA FIELD(CONTRACT,'-',1)
    DATA FIELD(CONTRACT,'-',2,2)
  END
  EXEC.LINE=\CMAINT.00\ ; GOSUB EXEC.SUB
RETURN
*
CCI:
  * CUSTOMER INQUIRY
  IF IL.MAJOR.VER='' THEN PRINT 'Only works in IL' ; RETURN
  GOSUB REMOVE.CONTROL.CHARS ;* Pasting from excel often brings in a CR or &nbsp
  DATA 0
  DATA 0
  DATA 0
  IF FIELD(ANS,' ',2) # '' THEN
    DATA FIELD(ANS,' ',2)
  END
  EXEC.LINE=\CDMAINT.00\ ; GOSUB EXEC.SUB
RETURN
*
CCM:
  * CUSTOMER MAINTENANCE
  IF IL.MAJOR.VER='' THEN PRINT 'Only works in IL' ; RETURN
  GOSUB REMOVE.CONTROL.CHARS ;* Pasting from excel often brings in a CR or &nbsp
  DATA 1
  DATA 0
  DATA 0
  IF FIELD(ANS,' ',2) # '' THEN
    DATA FIELD(ANS,' ',2)
  END
  EXEC.LINE=\CDMAINT.00\ ; GOSUB EXEC.SUB
RETURN
*
TM:
  * TABLE MAINTENANCE
  IF IL.MAJOR.VER='' THEN PRINT 'Only works in IL' ; RETURN
  DATA 1
  DATA 0
  EXEC.LINE=\TMAINT.00\ ; GOSUB EXEC.SUB
RETURN
*
RS:
  * Recall Shell
  IF IL.MAJOR.VER # 9 THEN PRINT 'Only works in IL9' ; RETURN
  DATA 1
  DATA 1
  RECALL=FIELD(ANS,' ',2)
  IF RECALL # '' THEN DATA RECALL
  EXECUTE \RECALL.00\
RETURN
*
ATB.FIND:
  * Search for an ATB in REV.ATB.LOG
  * HCAC>AF NUM.OF.ASSETS
  * NUM.OF.ASSETS
  *
  * IL.BPI                BILLING
  * FILE(S)               LS.MASTER,LS.BILLING  PT.PARTICIPATIONS,PT.BILLING
  * FIELD                 9
  * CHANGE LOG INDEX      02*0009
  * CHANGE LOG KEY        247
  * TYPE                  INTEGER
  * MASK                  MD0
  * S/MV                  S
  * CONTROLLING/DEPENDENT
  * SUB/MASTER FIELDS
  * CHG DESCRIPTION       Number Of Assets
  * The number of active assets associated with the contract.
  *
  IF IL.MAJOR.VER='' THEN PRINT 'Only works in IL' ; RETURN
  CALL FILE.OPEN.OK("IL.TB.CHNG.LOG", IL.TB.CHNG.LOG, FILE.OPEN.OK)
  IF NOT(FILE.OPEN.OK) THEN CRT 'Cannot open IL.TB.CHNG.LOG'      ; RETURN
  CALL FILE.OPEN.OK("IL.CHANGE.LOG.INDEX", IL.CHANGE.LOG.INDEX, FILE.OPEN.OK)
  IF NOT(FILE.OPEN.OK) THEN CRT 'Cannot open IL.CHANGE.LOG.INDEX' ; RETURN
  CALL FILE.OPEN.OK("REV.ATB.LOG", REV.ATB.LOG, FILE.OPEN.OK)
  IF NOT(FILE.OPEN.OK) THEN CRT 'Cannot open REV.ATB.LOG'         ; RETURN
  CALL FILE.OPEN.OK("HELP.TEXT.USA", HELP.TEXT.USA, FILE.OPEN.OK)
  IF NOT(FILE.OPEN.OK) THEN CRT 'Cannot open HELP.TEXT.USA'       ; RETURN
  MSK="L#22"
  ATB = FIELD(ANS," ",2)
  IF ATB="" THEN RETURN
  IF IL.MAJOR.VER=9 THEN
    BCI.ERROR=''
    READ AREC FROM REV.ATB.LOG, ATB ELSE BCI.ERROR='CANNOT READ REV.ATB.LOG ':ATB
  END ELSE
    CALL IDS.READ(AREC, REV.ATB.LOG, ATB, 0, 0, BCI.ERROR)
  END
  IF BCI.ERROR THEN
    ATBREC=""
    IF IL.MAJOR.VER=9 THEN
      EXEC.LINE=\SSELECT REV.ATB.LOG = "[\:ATB:\]"\
      CRT EXEC.LINE
      GOSUB EXEC.SUB
    END ELSE
      SELECT.COMMAND=\SELECT ALTERNATE_ID FROM REV_ATB_LOG_NF WHERE ALTERNATE_ID LIKE '%\:ATB:\%' ORDER BY ALTERNATE_ID\
      CRT SELECT.COMMAND
      CALL IDS.EXECUTE.ANSI.SQL.ERROR(SELECT.COMMAND, '', '', '', KEY.LIST, ERR, '', '', '', '0', '','')
      SELECT KEY.LIST
    END
    CTR=0
    LOOP
      READNEXT ID ELSE EXIT
      IF ID='' THEN CONTINUE
      CTR+=1
      PRINT CTR "L#4":ID
      ATBREC<CTR>=ID
    REPEAT
    IF CTR=0 THEN RETURN
    PRINT
    PRINT "Enter choice (1-":CTR:"): ": ; INPUT CHOICE
    IF CHOICE="" OR CHOICE="/" THEN RETURN
    ATB=ATBREC<CHOICE>
    IF ATB="" THEN RETURN
    IF IL.MAJOR.VER=9 THEN
      BCI.ERROR=''
      READ AREC FROM REV.ATB.LOG, ATB ELSE BCI.ERROR='ERROR REV.ATB.LOG ':ATB
    END ELSE
      CALL IDS.READ(AREC, REV.ATB.LOG, ATB, 0, 0, BCI.ERROR)
    END
    IF BCI.ERROR THEN
      CRT ATB:' not found in REV.ATB.LOG' ; RETURN
    END
  END
  *
  MAXV=DCOUNT(AREC<5>,@VM)
  FNAMES=""
  FOR J=1 TO MAXV
    IF AREC<5,J>[1,2] # "BK" THEN FNAMES :=AREC<5,J>:",":AREC<6,J>:"  "
  NEXT J
  *
  IF IL.MAJOR.VER=9 THEN
    BCI.ERROR=''
    READV CKEY FROM IL.CHANGE.LOG.INDEX, AREC<24>, 1 ELSE BCI.ERROR='ERROR IL.CHANGE.LOG.INDEX ':AREC<24>
  END ELSE
    CALL IDS.READV(CKEY, IL.CHANGE.LOG.INDEX, AREC<24>, '', 1, 0, 0, BCI.ERROR)
  END
  IF BCI.ERROR THEN CKEY=""
  IF IL.MAJOR.VER=9 THEN
    BCI.ERROR=''
    READ CHNG_REC FROM IL.TB.CHNG.LOG, CKEY ELSE BCI.ERROR='ERROR IL.TB.CHNG.LOG ':CKEY
  END ELSE
    CALL IDS.READ(CHNG_REC, IL.TB.CHNG.LOG, CKEY, 0, 0, BCI.ERROR)
  END
  IF BCI.ERROR THEN CHNG_REC=""
  IF IL.MAJOR.VER=9 THEN
    BCI.ERROR=''
    READ HELP.TEXT FROM HELP.TEXT.USA, ATB ELSE BCI.ERROR='ERROR HELP.TEXT.USA ':ATB
  END ELSE
    CALL IDS.READ(HELP.TEXT, HELP.TEXT.USA, ATB, 0, 0, BCI.ERROR)
  END
  IF BCI.ERROR THEN HELP.TEXT=""
  CONVERT "~" TO "" IN HELP.TEXT
  DEP=AREC<16>
  CONVERT @VM TO "," IN DEP
  PRINT ATB
  PRINT
  PRINT "IL.BPI" MSK               :AREC<1>
  PRINT "FILE(S)" MSK              :FNAMES
  PRINT "FIELD" MSK                :AREC<2>
  PRINT "CHANGE LOG INDEX" MSK     :AREC<24>
  PRINT "CHANGE LOG KEY" MSK       :CKEY
  PRINT "TYPE" MSK                 :AREC<3>
  PRINT "MASK" MSK                 :AREC<10>
  PRINT "S/MV" MSK                 :AREC<14>
  PRINT "CONTROLLING/DEPENDENT" MSK:AREC<15>
  PRINT "SUB/MASTER FIELDS" MSK    :DEP
  PRINT "CHG DESCRIPTION" MSK      :CHNG_REC<1>
  PRINT "COMMENTS" MSK             :AREC<32>
  PRINT
  MAXV=DCOUNT(HELP.TEXT<2>,@VM)
  FOR J=1 TO MAXV
    PRINT HELP.TEXT<2,J>
  NEXT J
RETURN
*
LISTA:
  * List users logged in, as well as locks
  IF IL.MAJOR.VER='' THEN PRINT 'Only works in IL' ; RETURN
  IF IL.MAJOR.VER=9 THEN GOSUB LISTA.IL9 ELSE GOSUB LISTA.IL10
RETURN
*
LISTA.IL9:
  * List all users/locks in IL9
  OPEN 'ACC' TO ACC.F ELSE STOP 201,'ACC'
  OPEN 'INFO.STATUS' TO INFO.STATUS ELSE STOP 201,'INFO.STATUS'
  SELECT ACC.F
  USER.LIST=''
  LOOP
    READNEXT PORT ELSE EXIT
    READ REC FROM ACC.F, PORT THEN
      READ MENU FROM INFO.STATUS, PORT'R%3' ELSE MENU='TCL'
      MENU=MENU<DCOUNT(MENU,@AM)> ;* Show the last item
      USER=REC<5>
      DATE=REC<2>
      TIME=REC<3>
      LOCATE PORT IN USER.LIST<4> BY 'AR' SETTING POS ELSE NULL
      INS USER BEFORE USER.LIST<1,POS>
      INS DATE BEFORE USER.LIST<2,POS>
      INS TIME BEFORE USER.LIST<3,POS>
      INS PORT BEFORE USER.LIST<4,POS>
      INS MENU BEFORE USER.LIST<5,POS>
    END
  REPEAT
  *GET.LOCKS
  LOCK.LIST=''
  FLIST=''
  FLIST<-1>='AS.FEATURE'
  FLIST<-1>='AS.MASTER'
  FLIST<-1>='AUVB.PARAMETER'
  FLIST<-1>='BQ.PARAMETER'
  FLIST<-1>='CS.MASTER'
  FLIST<-1>='DATA.MASKING.PARAMETER'
  FLIST<-1>='DB.RECORD.LOCKS'
  FLIST<-1>='DE.MASTER'
  FLIST<-1>='FIELD.SECURITY'
  FLIST<-1>='INFO-SYSTEM'
  FLIST<-1>='IT.INSURANCE'
  FLIST<-1>='IT.INSURANCE.AGENT'
  FLIST<-1>='LS.BANK.DEPOSIT'
  FLIST<-1>='LS.DISCOUNT.PACKAGE'
  FLIST<-1>='LS.DISCOUNT.WORKSHEET'
  FLIST<-1>='LS.GL.HISTORY'
  FLIST<-1>='LS.MASTER'
  FLIST<-1>='LS.POST.DATED.CHECK'
  FLIST<-1>='LS.SUPER.QUOTE'
  FLIST<-1>='LS.WK.CASH'
  FLIST<-1>='MISC'
  FLIST<-1>='MM.GROUP'
  FLIST<-1>='PARAMETER'
  FLIST<-1>='PROCESSOR.PARAMETER'
  FLIST<-1>='TRED.FUTURE.PROC.DATES'
  FLIST<-1>='USERS.MENUS'
  FLIST<-1>='WL.FOLLOW.UP'
  FLIST<-1>='WL.PARAMETER'
  *
  FOR G=1 TO DCOUNT(FLIST,@AM)
    FILE='DB.RECORD.LOCKS,':FLIST<G>
    OPEN FILE TO FVAR THEN
      SELECT FVAR
      LOOP
        READNEXT LOCK.ID ELSE EXIT
        READ REC FROM FVAR, LOCK.ID THEN
          PORT=REC<1>
          DATE=REC<2>
          TIME=REC<3>
          USER=REC<4>
          LOCK.LIST<1,-1>=FILE
          LOCK.LIST<2,-1>=LOCK.ID
          LOCK.LIST<3,-1>=PORT
          LOCK.LIST<4,-1>=DATE
          LOCK.LIST<5,-1>=TIME
          LOCK.LIST<6,-1>=USER
          LOCATE PORT IN USER.LIST<4> SETTING POS THEN
            USER.LIST<6,POS>=LOCK.ID:',':USER.LIST<6,POS>
          END
        END
      REPEAT
      CLOSE FVAR
    END
  NEXT G
  *
  PRINT @(-1):'USERS'
  PRINT
  PRINT 'Port':' ':'User''L#12':' ':'Date''L#10':' ':'Time''L#8':' ':
  PRINT 'Time On''L#8':' ':'Menu''L#30':' ':'L'
  PRINT '----':' ':STR('-',12):' ':STR('-',10):' ':STR('-',8):' ':
  PRINT STR('-',8):' ':STR('-',30):' ':'-'
  FOR F=1 TO DCOUNT(USER.LIST<1>,@VM)
    DUR=TIME()-USER.LIST<3,F>
    IF DUR<0 THEN DUR+=86400 ;* Roll over midnight, add back number of seconds in a day
    PRINT USER.LIST<4,F>'R#4':' ':
    PRINT USER.LIST<1,F>'L#12':' ':
    PRINT USER.LIST<2,F>'D4/':' ':
    PRINT USER.LIST<3,F>'MTS':' ':
    PRINT DUR'MTS':' ':
    PRINT USER.LIST<5,F>'L#30':' ':
    IF USER.LIST<6,F>#'' THEN PRINT '*' ELSE PRINT ' '
  NEXT F
  *
  PRINT
  PRINT 'LOCKS'
  PRINT
  PRINT 'Table''L#20':' ':'ID''L#25':' ':'Port''L#4':' ':
  PRINT 'Date''L#5':' ':'Time''L#5':' ':'User''L#15'
  PRINT STR('-',20):' ':STR('-',25):' ':STR('-',4):' ':
  PRINT STR('-',5):' ':STR('-',5):' ':STR('-',15)
  FOR L=1 TO DCOUNT(LOCK.LIST<1>,@VM)
    FILE=FIELD(LOCK.LIST<1,L>,',',2)
    PRINT FILE'L#20':' ':LOCK.LIST<2,L>'L#25':' ':LOCK.LIST<3,L>'R#4':' ':
    PRINT (LOCK.LIST<4,L>'D4/')[1,5]:' ':LOCK.LIST<5,L>'MT':' ':LOCK.LIST<6,L>'L#15'
  NEXT L
  *
  CLOSE ACC.F
  CLOSE INFO.STATUS
  *
RETURN
*
LISTA.IL10:
  * List all users/locks in IL10
  CRT 'User Sessions'
  CRT '-------------'
  SELECT.HDR=\USER_ID,LOGIN_FROM,LOGIN_DATE,LAST_ACTIVITY,CURR_TIME\
  SELECT.COMMAND=\SELECT USER_ID,LOGIN_FROM,LOGIN_DATE,LAST_ACTIVITY,CURRENT_TIMESTAMP \
  SELECT.COMMAND:=\FROM SYSTEM_SESSION ORDER BY USER_ID\
  EMAIL=''
  GOSUB IL10.SEL
  CRT ''
  CRT 'Record Locks'
  CRT '------------'
  *
  * Kudos to whoever at IDS cleaned up the mess that is IL9 locking!
  SELECT.HDR=\FILE_NAME,ID,LOCKED_USER,LOCKED_DATE\
  SELECT.COMMAND=\SELECT FILE_NAME,ID,LOCKED_USER,LOCKED_DATE\
  SELECT.COMMAND:=\ FROM DB_RECORD_LOCKS ORDER BY FILE_NAME,ID\
  GOSUB IL10.SEL
  CRT ''
  CRT 'Processing Flags'
  CRT '----------------'
  *
  * Show processing flags
  SELECT.HDR=\USER_ID,UPDATE_CODE,UPDATE_CODE_DATE,UPDATE_CODE_DESC\
  SELECT.COMMAND=\SELECT SS.USER_ID, SP.UPDATE_CODE, SP.UPDATE_CODE_DATE, SP.UPDATE_CODE_DESC \
  SELECT.COMMAND:=\FROM SESSION_PORTS SP LEFT OUTER JOIN SYSTEM_SESSION SS ON SS.SESSION_ID = SP.SESSION_ID \
  SELECT.COMMAND:=\WHERE UPDATE_CODE <> 0\
  GOSUB IL10.SEL
RETURN
*
SEARCH.EXAMPLE:
  * Calculate all possible ATB's for an example contract
  IF IL.MAJOR.VER # 9 THEN PRINT 'Only works in IL9' ; RETURN
  FILE=FIELD(ANS,' ',2)
  @ID=FIELD(ANS,' ',3)
  IF FILE='' OR @ID='' THEN
    PRINT 'Usage: SE <FNAME> <ID>'
    RETURN
  END
  OPEN FILE TO F ELSE PRINT 'Cannot open ':FILE ; RETURN
  OPEN "DICT ":FILE TO @DICT ELSE PRINT 'Cannot open DICT ':FILE ; RETURN
  READ @RECORD FROM F, @ID ELSE PRINT 'Cannot read ':@ID:' in ':FILE ; RETURN
  CLOSE F
  OUTPUT=''
  EXECUTE \SSELECT DICT \:FILE:\ WITH F1 = "I" USING DICT VOC\
  LOOP
    READNEXT FLD ELSE EXIT
    PRINT FLD:'=':
    VAL=CALCULATE(FLD)
    PRINT VAL
    IF @CONV # '' THEN VAL=OCONV(VAL,@CONV)
    *OUTPUT<-1>=FLD:'=':VAL
  REPEAT
  WRITE OUTPUT ON VOC, 'OUTPUT.TMP'
  EXECUTE \AE VOC OUTPUT.TMP\
RETURN
*
IL10.XREF:
  * Show metadata cross reference for a file or table.  Works best given an IL9 FILE.NAME like XREF LS.MASTER,LS.BILLING
  IF IL.MAJOR.VER # 10 THEN PRINT 'Only works in IL10' ; RETURN
  EMAIL=''
  FILE.NAME = FIELD(ANS,' ',2)
  FIELD.NAME = FIELD(ANS,' ',3)
  *
  SELECT.HDR=\BPI,FILE_NAME,FIELD_NAME,STRING_POS,TABLE_NAME,COLUMN_NAME,VALUE_TYPE,FIELD_TYPE\
  SELECT.COMMAND = \SELECT\
  SELECT.COMMAND := \ MFILES.BPI, MFILES.FILE_NAME, MFIELDS.FIELD_NAME, MFIELDS.STRING_POS, MFIELDS.TABLE_NAME,\
  SELECT.COMMAND := \ MFIELDS.COLUMN_NAME, MFIELDS.VALUE_TYPE, MFIELDS.FIELD_TYPE\
  SELECT.COMMAND := \ FROM METADATA_FILES MFILES \
  SELECT.COMMAND := \ LEFT OUTER JOIN METADATA_FIELDS MFIELDS ON MFILES.FILE_NAME = MFIELDS.FILE_NAME\
  IF INDEX(FILE.NAME,'%',1) THEN
    SELECT.COMMAND := \ WHERE (MFILES.FILE_NAME LIKE '\:FILE.NAME:\' OR MFILES.TABLE_NAME LIKE '\:FILE.NAME:\')\
  END ELSE
    SELECT.COMMAND := \ WHERE (MFILES.FILE_NAME = '\:FILE.NAME:\' OR MFILES.TABLE_NAME = '\:FILE.NAME:\')\
  END
  IF FIELD.NAME # '' THEN SELECT.COMMAND :=\ AND FIELD_NAME LIKE '%\:FIELD.NAME:\%'\
  SELECT.COMMAND := \ ORDER BY FILE_NAME, STRING_POS\
  *
  GOSUB IL10.SEL
RETURN
*
IL10.FIELD:
  * Show all ATB's for a file from METADATA_FIELDS, e.g. FIELD RENEWAL
  IF IL.MAJOR.VER # 10 THEN PRINT 'Only works in IL10' ; RETURN
  FLD = FIELD(ANS,' ',2)
  SELECT.HDR=\BPI,FILE_NAME,FIELD_NAME,MV_POS,TABLE_NAME,COLUMN_NAME,MV/S,TYPE,LEN,SCALE\
  SELECT.COMMAND = \SELECT BPI,FILE_NAME,FIELD_NAME,STRING_POS,TABLE_NAME,COLUMN_NAME,VALUE_TYPE,FIELD_TYPE,FIELD_LENGTH,SCALE\
  SELECT.COMMAND  :=\ FROM METADATA_FIELDS\
  SELECT.COMMAND  :=\ WHERE FIELD_NAME LIKE '%\:FLD:\%' OR COLUMN_NAME LIKE '%\:FLD:\%'\
  EMAIL=''
  GOSUB IL10.SEL
RETURN
*
IL10.DESC:
  * Show SQL table structure, this gets some columns not shown in META_DATA_FIELDS, but still doesn't include COMPUTED columns
  IF IL.MAJOR.VER # 10 THEN PRINT 'Only works in IL10' ; RETURN
  TABLE = FIELD(ANS,' ',2)
  SELECT.HDR=\COL,COLUMN_NAME,DATA_TYPE,WIDTH\
  IF DB='ORA' THEN
    SELECT.COMMAND = \SELECT COLUMN_ID, COLUMN_NAME, DATA_TYPE, CHAR_COL_DECL_LENGTH \
    SELECT.COMMAND:= \FROM ALL_TAB_COLUMNS \
    SELECT.COMMAND:= \WHERE TABLE_NAME = '\:TABLE:\'\
  END ELSE
    SELECT.COMMAND = \SELECT ORDINAL_POSITION, COLUMN_NAME, DATA_TYPE, CHARACTER_MAXIMUM_LENGTH \
    SELECT.COMMAND:= \FROM INFORMATION_SCHEMA.COLUMNS \
    SELECT.COMMAND:= \WHERE TABLE_NAME = '\:TABLE:\'\
  END
  SELECT.COMMAND:= \ORDER BY 1\
  EMAIL=''
  GOSUB IL10.SEL
RETURN
*
IL10.NSEL:
  * Run a SELECT statement and display the results
  IF IL.MAJOR.VER # 10 THEN PRINT 'Only works in IL10' ; RETURN
  PRMT=1
  EXECLINE='SELECT ':FIELD(ANS,' ',2,999)
  CALL EXECUTE.SELECT.SUB(EXECLINE,ERR.MSG,1,'',0,SELECTED.LIST,1,'',0,'',0,0)
  CTR=0
  LOOP
    READNEXT ID FROM SELECTED.LIST ELSE EXIT
    CTR+=1
    CRT CTR'R#6':') ':ID
    IF CTR/20=INT(CTR/20) AND PRMT THEN
      CRT ':':
      INPUT AAA
      IF AAA = '/' OR AAA='Q' THEN RETURN
      IF AAA = 'N' THEN PRMT=0
    END
  REPEAT
RETURN
*
SQL.SEL:
  * Run a SELECT statement from the command line and display the results, e.g. SQL SELECT COUNT(*) FROM WK_INVOICE_NF
  IF IL.MAJOR.VER # 10 THEN PRINT 'Only works in IL10' ; RETURN
  SELECT.HDR=''
  SELECT.COMMAND=FIELD(ANS,' ',2,200)
  EMAIL=''
  GOSUB IL10.SEL
RETURN
*
SQL.FILE:
  * Run a SELECT statement from a file and display the results, e.g. SQLF _HOLD_ TEST.sql
  * This expects the first line of the SQL file to be a comment containing delimited field names
  * It jams all lines in the file together before executing, so use /* Comments */ NOT -- Comments
  IF IL.MAJOR.VER # 10 THEN PRINT 'Only works in IL10' ; RETURN
  SELECT.HDR=''
  FILE=FIELD(ANS,' ',2) ;* Spaces in file name are not supported
  EMAIL=FIELD(ANS,' ',3)
  OSREAD SELECT.COMMAND FROM FILE ELSE CRT FILE:' not found' ; RETURN
  IF SELECT.COMMAND<1>[1,2]='--' THEN
    SELECT.HDR=SELECT.COMMAND<1>[3,999]
    CONVERT CHAR(9) TO @VM IN SELECT.HDR
    DEL SELECT.COMMAND<1>
  END
  CONVERT @AM TO ' ' IN SELECT.COMMAND
  SWAP CHAR(13):CHAR(10) WITH ' ' IN SELECT.COMMAND
  * Check for parameter requests before running SQL
  LOOP
    I=INDEX(SELECT.COMMAND,'@',1)
  UNTIL I=0 DO
    I+=1 ; P='' ; DONE=0
    LOOP
      C=SELECT.COMMAND[I,1]
      IF (C < 'A' OR C > 'Z') AND C # '_' AND C # '.' THEN DONE=1
    UNTIL DONE DO
      P:=C
      I+=1
    REPEAT
    CRT 'Enter a value for ':P:':':
    INPUT VAL
    SWAP '@':P WITH VAL IN SELECT.COMMAND
  REPEAT
  GOSUB IL10.SEL
RETURN
*
SQL.SEL.LIST:
  * This runs a SQL command and saves the results to a list, e.g. SQL-LIST L1 SELECT TOP 10 ALTERNATE_ID FROM LS_MASTER_NF
  * Will run the SQL and save the results to a saved list
  IF IL.MAJOR.VER # 10 THEN PRINT 'Only works in IL10' ; RETURN
  LIST=FIELD(ANS,' ',2)
  SELECT.COMMAND=FIELD(ANS,' ',3,200)
  FIRST.WORD=FIELD(ANS,' ',3)
  IF FIRST.WORD = 'SELECT' THEN
    PRINT SELECT.COMMAND
    PARAM=''
    CALL IDS.EXECUTE.ANSI.SQL(SELECT.COMMAND,PARAM,'','',KEY.LIST)
    CALL CONVERT.LIST(KEY.LIST)
    EXECUTE \SAVE.LIST \:LIST PASSLIST KEY.LIST
  END ELSE
    * Assume we're running from a file
      SELECT.HDR=''
      FILE=FIELD(ANS,' ',3) ;* Spaces in file name are not supported
      OSREAD SELECT.COMMAND FROM FILE ELSE CRT FILE:' not found' ; RETURN
      CONVERT CHAR(13) TO '' IN SELECT.COMMAND
      CONVERT CHAR(10) TO ' ' IN SELECT.COMMAND
      PARAM=''
      FOR F=DCOUNT(SELECT.COMMAND,@AM) TO 1 STEP -1
        IF SELECT.COMMAND<F>[1,2]='--' THEN DEL SELECT.COMMAND<F>
      NEXT F
      CRT SELECT.COMMAND
      CALL IDS.EXECUTE.ANSI.SQL(SELECT.COMMAND,PARAM,'','',KEY.LIST)
      CALL CONVERT.LIST(KEY.LIST)
      EXECUTE \SAVE.LIST \:LIST PASSLIST KEY.LIST
  END
RETURN
*
IL10.SEL:
  * Run a SELECT statement and display the results
  IF IL.MAJOR.VER # 10 THEN PRINT 'Only works in IL10' ; RETURN
  PARAM=''
  CONVERT ',' TO @VM IN SELECT.HDR
  IF SHOW.SELECT THEN PRINT SELECT.COMMAND ; PRINT
  CALL IDS.EXECUTE.ANSI.SQL.ERROR(SELECT.COMMAND, PARAM, '', '', KEY.LIST, ERR, '', '', '', '0', '','')
  DISP.MAX=DCOUNT(KEY.LIST,@AM)
  PRINT DISP.MAX:' items selected, ERR=':ERR
  IF DISP.MAX=0 THEN RETURN
  IF EMAIL # '' THEN
    CSV.FILE=FILE:'.csv'
    CONVERT ',' TO '|' IN KEY.LIST ;* Deal with embedded commas in the data
    CONVERT @VM TO ',' IN KEY.LIST
    IF SELECT.HDR # '' THEN
      CONVERT @VM TO ',' IN SELECT.HDR
      INS SELECT.HDR BEFORE KEY.LIST<1>
    END
    SWAP @AM WITH CHAR(10) IN KEY.LIST
    WRITE KEY.LIST ON HOLD, CSV.FILE
    CALL STACK.MAIL.SUB('@LOGNAME', '@LOGNAME', '_HOLD_/':CSV.FILE, CSV.FILE, 'PATH')
  END ELSE
    * Get widths
    CONVERT ',' TO @VM IN SELECT.HDR
    W=''
    IF SELECT.HDR # '' THEN
      INS SELECT.HDR BEFORE KEY.LIST<1>
      DISP.MAX+=1
    END
    FOR R=1 TO 100 ;* Just check the first 100 rows for widths
      IF KEY.LIST<R>='' THEN EXIT
      FOR C=1 TO DCOUNT(KEY.LIST<R>,@VM)
        L=LEN(KEY.LIST<R,C>)
        IF L > W<C> THEN W<C>=L
      NEXT C
    NEXT R
    *
    * Print the header
    DISP.START=1
    IF SELECT.HDR # '' THEN
      DISP.START=2
      FOR C=1 TO DCOUNT(KEY.LIST<1>,@VM)
        PRINT FMT(KEY.LIST<1,C>,'L#':W<C>):' ':
      NEXT C
      PRINT
      *
      FOR C=1 TO DCOUNT(KEY.LIST<1>,@VM)
        PRINT STR('-',W<C>):' ':
      NEXT C
      PRINT
    END
    * Now the data
    FOR R=DISP.START TO DISP.MAX
      IF SELECT.HDR = '' THEN CRT R,:
      FOR C=1 TO DCOUNT(KEY.LIST<R>,@VM)
        PRINT FMT(KEY.LIST<R,C>,'L#':W<C>):' ':
      NEXT C
      PRINT
    NEXT R
  END
RETURN
*
LIST.MODULES:
  * List all modules in the system
  IF IL.MAJOR.VER # 9 THEN PRINT 'Only works in IL9' ; RETURN
  OPEN 'MODULE.FILE,IL' TO MODULES ELSE CRT 'ERROR OPENING:MODULES' ; RETURN
  OPEN 'IL.APP.PARAMS' TO IL.APP.PARAMS ELSE CRT 'ERROR OPENING:IL.APP.PARAMS' ; RETURN
  OPEN 'ACCOUNT.PARAMS' TO ACCOUNT.PARAMS ELSE CRT 'ERROR OPENING:ACCOUNT.PARAMS' ; RETURN
  READ PARAMS FROM ACCOUNT.PARAMS, 'VERSION' ELSE PARAMS=''
  MODULES.ACTIVE=PARAMS<1>
  SYSNUM=PARAMS<11>
  READ MODULES.AVAIL FROM IL.APP.PARAMS, SYSNUM:'*MODULES' ELSE R=''
  FOR F=1 TO LEN(MODULES.AVAIL)
    ACTIVE=MODULES.ACTIVE[F,1]
    AVAIL=MODULES.AVAIL[F,1]
    READV DESC FROM MODULES, F, 1 ELSE DESC='Unknown'
    CRT F 'R#3':' ':
    IF AVAIL THEN
      IF ACTIVE THEN CRT '  1': ELSE CRT '  0':
    END ELSE
      CRT 'N/A':
    END
    CRT ' ':DESC
  NEXT F
RETURN
*
LIST.PARAM:
  * List PARAMETER records, also used from GET.PARAMETER.BPI for XREF info
  * 1=PREFIX
  * 2=DESCRIPTION
  * 3=TABLE NAME
  * 4=BPI
  IF IL.MAJOR.VER='' THEN PRINT 'Only works in IL' ; RETURN
  P=''
  P<1,-1>=STR('-', 18)                  ; P<2,-1>=STR('-',33)
  P<3,-1>=STR('-',30)                   ; P<4,-1>=STR('-',30)
  P<1,-1>='Key Prefix'                  ; P<2,-1>='Description'
  P<3,-1>='RDBMS Table'                 ; P<4,-1>='BPI'
  P<1,-1>=STR('-', 18)                  ; P<2,-1>=STR('-',33)
  P<3,-1>=STR('-',30)                   ; P<4,-1>=STR('-',30)
  P<1,-1>='00*00'                       ; P<2,-1>='Lease System Parameters'
  P<3,-1>='PARAMETER_NF'                ; P<4,-1>='PARAMETER'
  P<1,-1>='00*00A'                      ; P<2,-1>='Temporary Lease System Params'
  P<3,-1>='TEMP_PARAMETER_NF'           ; P<4,-1>='TEMP.PARAMETER'
  P<1,-1>='00*00B'                      ; P<2,-1>='Additional Lease System Params'
  P<3,-1>='ADDL_PARAMETER_NF'           ; P<4,-1>='ADDL.PARAMETER'
  P<1,-1>='00*00IRR'                    ; P<2,-1>='IRR Parameter'
  P<3,-1>='IRR_PARAMETER_NF'            ; P<4,-1>='IRR.PARAMETER'
  P<1,-1>='00*00RPT'                    ; P<2,-1>='Report Parameter'
  P<3,-1>='RPT_PARAMETER_NF'            ; P<4,-1>='RPT.PARAMETER'
  P<1,-1>='*00'                         ; P<2,-1>='Lessor Parameters'
  P<3,-1>='LESSOR_NF'                   ; P<4,-1>='LESSOR'
  P<1,-1>='*00A'                        ; P<2,-1>='Temporary Lessor'
  P<3,-1>='TEMP_LESSOR_NF'              ; P<4,-1>='TEMP.LESSOR'
  P<1,-1>='*00B'                        ; P<2,-1>='Additional Lessor'
  P<3,-1>='ADDL_LESSOR_NF'              ; P<4,-1>='ADDL.LESSOR'
  P<1,-1>='*00GL'                       ; P<2,-1>='Multiple Bookset'
  P<3,-1>='MULTIPLE_BOOKSET_NF'         ; P<4,-1>='MULTIPLE.BOOKSET'
  P<1,-1>='*00UD'                       ; P<2,-1>='Lessor User-Defined'
  P<3,-1>='LESSOR_USER_NF'              ; P<4,-1>='LESSOR.USER'
  P<1,-1>='*ACH'                        ; P<2,-1>='Lessor ACH Flags'
  P<3,-1>='LESSOR_ACH_FLAGS_NF'         ; P<4,-1>='LESSOR.ACH.FLAGS'
  P<1,-1>='*ADVICE*'                    ; P<2,-1>='Advice Follow-up'
  P<3,-1>='ADVICE_FOLLOW_UP_NF'         ; P<4,-1>='ADVICE.FOLLOW.UP'
  P<1,-1>='*COMMISSION'                 ; P<2,-1>='Commission'
  P<3,-1>='COMMISSION_NF'               ; P<4,-1>='COMMISSION'
  P<1,-1>='*WARNING.MESSAGES'           ; P<2,-1>='Lessor Warning Messages'
  P<3,-1>='LESSOR_WARNING_MESSAGES_NF'  ; P<4,-1>='LESSOR.WARNING.MESSAGES'
  P<1,-1>='[Lessor Id]'                 ; P<2,-1>='Lessor Address'
  P<3,-1>='LS_ADDRESS_NF'               ; P<4,-1>='LS.ADDRESS'
  P<1,-1>='10*'                         ; P<2,-1>='Personnel'
  P<3,-1>='PERSONNEL_INFO_NF'           ; P<4,-1>='PERSONNEL.INFO'
  P<1,-1>='12*'                         ; P<2,-1>='Office'
  P<3,-1>='OFFICE_DATA_NF'              ; P<4,-1>='OFFICE.DATA'
  P<1,-1>='13*'                         ; P<2,-1>='Vendor/Dealer'
  P<3,-1>='PARAM_ADDRESS_NF'            ; P<4,-1>='PARAM.ADDRESS'
  P<1,-1>='13APA*'                      ; P<2,-1>='Additional Vendor/Dealer Address'
  P<3,-1>='ADDL_PARAM_ADDRESS_NF'       ; P<4,-1>='ADDL.PARAM.ADDRESS'
  P<1,-1>='14*'                         ; P<2,-1>='Reason Code'
  P<3,-1>='REASON_CODE_NF'              ; P<4,-1>='REASON.CODE'
  P<1,-1>='15*'                         ; P<2,-1>='Collateral Code'
  P<3,-1>='TB_COLLATERAL_NF'            ; P<4,-1>='COLLATERAL_NON_UD'
  P<1,-1>='16*'                         ; P<2,-1>='Equipment Category'
  P<3,-1>='EQUIP_CODE_DEFAULTS_NF'      ; P<4,-1>='EQUIP.CODE.DEFAULTS'
  P<1,-1>='17*'                         ; P<2,-1>='Tax Description'
  P<3,-1>='TAX_DESC_TBL_NF'             ; P<4,-1>='TAX.DESC.TBL'
  P<1,-1>='18*'                         ; P<2,-1>='Property Tax Status'
  P<3,-1>='PROP_TAX_STATUS_TBL_NF'      ; P<4,-1>='PROP.TAX.STATUS.TBL'
  P<1,-1>='19*'                         ; P<2,-1>='Region'
  P<3,-1>='REGION_TABLE_NF'             ; P<4,-1>='REGION.TABLE'
  P<1,-1>='20*'                         ; P<2,-1>='Remit To'
  P<3,-1>='REMIT_ADDRESS_NF'            ; P<4,-1>='REMIT.ADDRESS'
  P<1,-1>='21*'                         ; P<2,-1>='Base Rate Indicator'
  P<3,-1>='FLOAT_BANK_NF'               ; P<4,-1>='FLOAT.BANK'
  P<1,-1>='22*'                         ; P<2,-1>='Broker Address'
  P<3,-1>='BROKER_TABLE_NF'             ; P<4,-1>='BROKER.TABLE'
  P<1,-1>='23*'                         ; P<2,-1>='General Ledger Account'
  P<3,-1>='GL_ACCT_TABLE_NF'            ; P<4,-1>='GL.ACCT.TABLE'
  P<1,-1>='24*'                         ; P<2,-1>='Branch'
  P<3,-1>='BRANCH_DATA_NF'              ; P<4,-1>='BRANCH.DATA'
  P<1,-1>='26*'                         ; P<2,-1>='Department'
  P<3,-1>='DEPARTMENT_NF'               ; P<4,-1>='DEPARTMENT'
  P<1,-1>='27*'                         ; P<2,-1>='Business'
  P<3,-1>='TB_BUSINESS_NF'              ; P<4,-1>='BUSINESS_NON_UD'
  P<1,-1>='28*'                         ; P<2,-1>='Program Type'
  P<3,-1>='PROG_TYPE_DEFAULTS_NF'       ; P<4,-1>='PROG.TYPE.DEFAULTS'
  P<1,-1>='29*'                         ; P<2,-1>='Payment Plan'
  P<3,-1>='TB_PAYMENT_PLAN_NF'          ; P<4,-1>='PAYMENT.PLAN_NON_UD'
  P<1,-1>='30*'                         ; P<2,-1>='Promotion'
  P<3,-1>='PROMOTION_TBL_NF'            ; P<4,-1>='PROMOTION.TBL'
  P<1,-1>='31*'                         ; P<2,-1>='Account Type'
  P<3,-1>='TB_ACCT_TYPE_NF'             ; P<4,-1>='ACCT.TYPE_NON_UD'
  P<1,-1>='32*'                         ; P<2,-1>='Business Type'
  P<3,-1>='TB_BUSINESS_TYPE_NF'         ; P<4,-1>='BUSINESS.TYPE_NON_UD'
  P<1,-1>='33*'                         ; P<2,-1>='Application Status'
  P<3,-1>='TB_STATUS_NF'                ; P<4,-1>='STATUS_NON_UD'
  P<1,-1>='34*'                         ; P<2,-1>='Disposition Payment Type'
  P<3,-1>='TB_DISP_PAYMENT_TYPE_NF'     ; P<4,-1>='DISP.PAYMENT.TYPE_NON_UD'
  P<1,-1>='35*'                         ; P<2,-1>='Disposition/Inventory'
  P<3,-1>='DISP_INVENT_TABLE_NF'        ; P<4,-1>='DISP.INVENT.TABLE'
  P<1,-1>='36*'                         ; P<2,-1>='Bank Additional User-Defined'
  P<3,-1>='AUS_BANKS_NF'                ; P<4,-1>='AUS.BANKS'
  P<1,-1>='39*'                         ; P<2,-1>='Product Line'
  P<3,-1>='PROD_LINE_DEFAULTS_NF'       ; P<4,-1>='PROD.LINE.DEFAULTS'
  P<1,-1>='40*'                         ; P<2,-1>='Insurance Type'
  P<3,-1>='TB_INSURANCE_TYPE_NF'        ; P<4,-1>='INSURANCE.TYPE_NON_UD'
  P<1,-1>='41*'                         ; P<2,-1>='Insurance Status'
  P<3,-1>='TB_INSURANCE_STATUS_NF'      ; P<4,-1>='INSURANCE.STATUS_NON_UD'
  P<1,-1>='42*'                         ; P<2,-1>='Contract Status'
  P<3,-1>='CONTRACT_STATUS_INFO_NF'     ; P<4,-1>='CONTRACT.STATUS.INFO'
  P<1,-1>='43*'                         ; P<2,-1>='Guaranteed Residual'
  P<3,-1>='TB_GUARANTEED_RESIDUAL_NF'   ; P<4,-1>='GUARANTEED.RESIDUAL_NON_UD'
  P<1,-1>='45*'                         ; P<2,-1>='Country Code'
  P<3,-1>='COUNTRY_CODES_NF'            ; P<4,-1>='COUNTRY.CODES'
  P<1,-1>='ACTIVITY.DE*'                ; P<2,-1>='Activity (Inv. Interface)'
  P<3,-1>='INV_INT_DATA_ELEMENTS_NF'    ; P<4,-1>='INV.INT.DATA.ELEMENTS'
  P<1,-1>='ADDL.BUYOUT*'                ; P<2,-1>='Additional Buyout Info'
  P<3,-1>='ADDL_BUYOUT_DEFAULT_NF'      ; P<4,-1>='ADDL.BUYOUT.DEFAULT'
  P<1,-1>='ADJ*'                        ; P<2,-1>='Adjustment Code'
  P<3,-1>='ADJUSTMENT_CODE_TBL_NF'      ; P<4,-1>='ADJUSTMENT.CODE.TBL'
  P<1,-1>='ADMIN*'                      ; P<2,-1>='Administrative Code'
  P<3,-1>='TB_ADMINISTRATIVE_CODE_NF'   ; P<4,-1>='ADMINISTRATIVE.CODE_NON_UD'
  P<1,-1>='AP.INTERFACE*1'              ; P<2,-1>='API Parameters'
  P<3,-1>='API_PARAMETERS_NF'           ; P<4,-1>='API.PARAMETERS'
  P<1,-1>='ASSET.DE*'                   ; P<2,-1>='Asset (Inv. Interface)'
  P<3,-1>='INV_INT_DATA_ELEMENTS_NF'    ; P<4,-1>='INV.INT.DATA.ELEMENTS'
  P<1,-1>='ASSET.STATUS*'               ; P<2,-1>='Asset Status'
  P<3,-1>='TB_ASSET_STATUS_NF'          ; P<4,-1>='ASSET.STATUS_NON_UD'
  P<1,-1>='ASSOCIATION*'                ; P<2,-1>='Association'
  P<3,-1>='ASSOC_REL_PARTY_NF'          ; P<4,-1>='ASSOC.REL.PARTY'
  P<1,-1>='BANK*'                       ; P<2,-1>='Bank Address'
  P<3,-1>='BANK_ADDRESS_NF'             ; P<4,-1>='BANK.ADDRESS'
  P<1,-1>='BANK.ADDL*'                  ; P<2,-1>='Additional Bank Address'
  P<3,-1>='ADDL_BANK_ADDRESS_NF'        ; P<4,-1>='ADDL.BANK.ADDRESS'
  P<1,-1>='BI.TYPE*'                    ; P<2,-1>='Blended Income Type'
  P<3,-1>='TB_BLENDED_INCOME_TYPE_NF'   ; P<4,-1>='BLENDED.INCOME.TYPE_NON_UD'
  P<1,-1>='BID*'                        ; P<2,-1>='Blended Income Defaults'
  P<3,-1>='BLENDED_INCOME_DEF_NF'       ; P<4,-1>='BLENDED.INCOME.DEF'
  P<1,-1>='BLENDED.INCOME*'             ; P<2,-1>='Blended Income Parameter'
  P<3,-1>='BLENDED_INCOME_TBL_NF'       ; P<4,-1>='BLENDED.INCOME.TBL'
  P<1,-1>='BUS.PLAN*'                   ; P<2,-1>='Business Plan'
  P<3,-1>='BUS_PLAN_DEFAULTS_NF'        ; P<4,-1>='BUS.PLAN.DEFAULTS'
  P<1,-1>='BUS.SEG*'                    ; P<2,-1>='Business Segment'
  P<3,-1>='BUS_SEGMENT_NF'              ; P<4,-1>='BUS.SEGMENT'
  P<1,-1>='BUYOUT*'                     ; P<2,-1>='Buyout Parameters'
  P<3,-1>='BUYOUT_DEFAULT_NF'           ; P<4,-1>='BUYOUT.DEFAULT'
  P<1,-1>='CADDR.DE*'                   ; P<2,-1>='Customer Address (Inv. Interface)'
  P<3,-1>='INV_INT_DATA_ELEMENTS_NF'    ; P<4,-1>='INV.INT.DATA.ELEMENTS'
  P<1,-1>='CCA*'                        ; P<2,-1>='CCA Class'
  P<3,-1>='CCA_CLASS_DEPR_NF'           ; P<4,-1>='null'
  P<1,-1>='CHECK.TYPE*'                 ; P<2,-1>='Check Type'
  P<3,-1>='CHECK_TYPE_NF'               ; P<4,-1>='CHECK.TYPE'
  P<1,-1>='CHRG.DE*'                    ; P<2,-1>='Charge Info (Inv. Interface)'
  P<3,-1>='INV_INT_DATA_ELEMENTS_NF'    ; P<4,-1>='INV.INT.DATA.ELEMENTS'
  P<1,-1>='CHRG.TYPE*'                  ; P<2,-1>='Open Item Charge Types'
  P<3,-1>='CHARGE_TYPE_TABLE_NF'        ; P<4,-1>='CHARGE.TYPE.TABLE'
  P<1,-1>='CHRG.TYPE.INDEX*'            ; P<2,-1>='Open Item Charge Type Indexes'
  P<3,-1>='CHARGE_TYPE_INDEX_NF'        ; P<4,-1>='CHARGE.TYPE.INDEX'
  P<1,-1>='CNTC.DE*'                    ; P<2,-1>='Contact (Inv. Interface)'
  P<3,-1>='INV_INT_DATA_ELEMENTS_NF'    ; P<4,-1>='INV.INT.DATA.ELEMENTS'
  P<1,-1>='CURRENCY*'                   ; P<2,-1>='Currency Code'
  P<3,-1>='CURRENCY_CODES_NF'           ; P<4,-1>='CURRENCY.CODES'
  P<1,-1>='DEALER.DISTRICT*'            ; P<2,-1>='Dealer District'
  P<3,-1>='TB_DEALER_DISTRICT_NF'       ; P<4,-1>='DEALER.DISTRICT_NON_UD'
  P<1,-1>='DEALER.PARAM*'               ; P<2,-1>='Dealer Parameter'
  P<3,-1>='DEALER_PARAM_NF'             ; P<4,-1>='DEALER.PARAM'
  P<1,-1>='DEALER.REGION*'              ; P<2,-1>='Dealer Region'
  P<3,-1>='TB_DEALER_REGION_NF'         ; P<4,-1>='DEALER.REGION_NON_UD'
  P<1,-1>='DEALER.SALESMAN*'            ; P<2,-1>='Dealer Salesman'
  P<3,-1>='DLR_SALESMAN_NF'             ; P<4,-1>='DLR.SALESMAN'
  P<1,-1>='DEALER.SERIES*'              ; P<2,-1>='Dealer Series'
  P<3,-1>='TB_DEALER_SERIES_NF'         ; P<4,-1>='DEALER.SERIES_NON_UD'
  P<1,-1>='DEALER.STATUS*'              ; P<2,-1>='Dealer Status'
  P<3,-1>='DEALER_STATUS_NF'            ; P<4,-1>='DEALER.STATUS'
  P<1,-1>='DLR.RECOURSE*'               ; P<2,-1>='Dealer Recourse'
  P<3,-1>='TB_DEALER_RECOURSE_NF'       ; P<4,-1>='DEALER.RECOURSE_NON_UD'
  P<1,-1>='EARLY.TERM.OPTION*'          ; P<2,-1>='Early Term Option'
  P<3,-1>='TB_EARLY_TERM_OPTION_NF'     ; P<4,-1>='EARLY.TERM.OPTION_NON_UD'
  P<1,-1>='ER*'                         ; P<2,-1>='Exchange Rate'
  P<3,-1>='EXCHANGE_RATE_NF'            ; P<4,-1>='EXCHANGE.RATE'
  P<1,-1>='FAC*'                        ; P<2,-1>='Void Factura Reason'
  P<3,-1>='TB_VOID_FACTURA_REASON_NF'   ; P<4,-1>='VOID.FACTURA.REASON_NON_UD'
  P<1,-1>='FIN.CLASS*'                  ; P<2,-1>='Finance Class'
  P<3,-1>='TB_FINANCE_CLASS_NF'         ; P<4,-1>='FINANCE.CLASS_NON_UD'
  P<1,-1>='FIN.PLAN*'                   ; P<2,-1>='Finance Plan'
  P<3,-1>='TB_FINANCE_PLAN_NF'          ; P<4,-1>='FINANCE.PLAN_NON_UD'
  P<1,-1>='FOLLOW.UP*'                  ; P<2,-1>='Follow Up'
  P<3,-1>='FOLLOW_UP_CODES_NF'          ; P<4,-1>='FOLLOW.UP.CODES'
  P<1,-1>='GL.LINK.INDEX*'              ; P<2,-1>='General Ledger Link Index'
  P<3,-1>='TB_GL_LINK_INDEX_NF'         ; P<4,-1>='GL.LINK.INDEX_NON_UD'
  P<1,-1>='GROUP.MISC.CODES*'           ; P<2,-1>='Group Misc GL Codes'
  P<3,-1>='GROUP_MISC_CODES_NF'         ; P<4,-1>='GROUP.MISC.CODES'
  P<1,-1>='HOLIDAY.TBL*'                ; P<2,-1>='Holiday/Weekend'
  P<3,-1>='HOLIDAY_WEEKEND_NF'          ; P<4,-1>='HOLIDAY.WEEKEND'
  P<1,-1>='IDC.DESC*'                   ; P<2,-1>='IDC Description'
  P<3,-1>='TB_IDC_DESC_NF'              ; P<4,-1>='IDC.DESC_NON_UD'
  P<1,-1>='INVOICE.FORMAT*'             ; P<2,-1>='Invoice Format'
  P<3,-1>='INVOICE_FORMAT_TABLE_NF'     ; P<4,-1>='INVOICE.FORMAT.TABLE'
  P<1,-1>='IP*'                         ; P<2,-1>='Insurance Parameter'
  P<3,-1>='INSURANCE_PARAMETER_NF'      ; P<4,-1>='INSURANCE.PARAMETER'
  P<1,-1>='IRS.CAT*'                    ; P<2,-1>='IRS Category/Tax'
  P<3,-1>='IRS_CAT_DEFAULTS_NF'         ; P<4,-1>='IRS.CAT.DEFAULTS'
  P<1,-1>='ITP'                         ; P<2,-1>='Insurance Tape Parameter'
  P<3,-1>='INS_TAPE_PARAMETER_NF'       ; P<4,-1>='INS.TAPE.PARAMETER'
  P<1,-1>='L.NATIONALITY*'              ; P<2,-1>='Nationality'
  P<3,-1>='TB_NATIONALITY_NF'           ; P<4,-1>='NATIONALITY_NON_UD'
  P<1,-1>='LANG*'                       ; P<2,-1>='Language'
  P<3,-1>='TB_LANGUAGE_NF'              ; P<4,-1>='LANGUAGE_NON_UD'
  P<1,-1>='LEGAL.S*'                    ; P<2,-1>='Legal Status'
  P<3,-1>='TB_LEGAL_STATUS_NF'          ; P<4,-1>='LEGAL.STATUS_NON_UD'
  P<1,-1>='LESSEE.CONTACT*'             ; P<2,-1>='Lessee Contact Permitted'
  P<3,-1>='TB_LESSEE_CONTACT_PERMIT_NF' ; P<4,-1>='LESSEE.CONT.PERMITTED_NON_UD'
  P<1,-1>='LESSOR.SUB*'                 ; P<2,-1>='Lessor Subsidiary'
  P<3,-1>='SUBSIDIARY_ADDRESS_NF'       ; P<4,-1>='SUBSIDIARY.ADDRESS'
  P<1,-1>='LKE.POOL*'                   ; P<2,-1>='Like Kind Exchange Pool'
  P<3,-1>='TB_LIKE_KIND_EXCHANGE_PO_NF' ; P<4,-1>='LIKE.KIND.EXCHANGE.POOL_NON_UD'
  P<1,-1>='LOCAL.SIC.CODE*'             ; P<2,-1>='Local SIC Code'
  P<3,-1>='LOCAL_SIC_CODE_TBL_NF'       ; P<4,-1>='LOCAL.SIC.CODE.TBL'
  P<1,-1>='LOCKBOX.PARAMS'              ; P<2,-1>='Lockbox Parameters'
  P<3,-1>='LOCKBOX_PARAMETERS_NF'       ; P<4,-1>='LOCKBOX.PARAMETERS'
  P<1,-1>='MILE.CAT*'                   ; P<2,-1>='Mileage Category'
  P<3,-1>='TB_MILEAGE_CATEGORY_NF'      ; P<4,-1>='MILEAGE.CATEGORY_NON_UD'
  P<1,-1>='MISC.PARAM*'                 ; P<2,-1>='Miscellaneous Parameters'
  P<3,-1>='MISC_PARAM_DEFAULTS_NF'      ; P<4,-1>='MISC.PARAM.DEFAULTS'
  P<1,-1>='MMR.ASSET.DE*'               ; P<2,-1>='MMR Asset (Inv. Interface)'
  P<3,-1>='INV_INT_DATA_ELEMENTS_NF'    ; P<4,-1>='INV.INT.DATA.ELEMENTS'
  P<1,-1>='MMR.ASSET.RATE.DE*'          ; P<2,-1>='MMR Asset Rate (Inv. Interface)'
  P<3,-1>='INV_INT_DATA_ELEMENTS_NF'    ; P<4,-1>='INV.INT.DATA.ELEMENTS'
  P<1,-1>='MMR.CHRG.DE*'                ; P<2,-1>='MMR Charge (Inv. Interface)'
  P<3,-1>='INV_INT_DATA_ELEMENTS_NF'    ; P<4,-1>='INV.INT.DATA.ELEMENTS'
  P<1,-1>='NJS.FLAG'                    ; P<2,-1>='NJS Flag'
  P<3,-1>='NJS_FLAG_NF'                 ; P<4,-1>='NJS.FLAG'
  P<1,-1>='PAYMENT.STATUS*'             ; P<2,-1>='Payment Status'
  P<3,-1>='TB_PAYMENT_STATUS_NF'        ; P<4,-1>='PAYMENT.STATUS_NON_UD'
  P<1,-1>='PAYMENT.TYPE*'               ; P<2,-1>='Payment Type'
  P<3,-1>='PYMT_TYPE_NF'                ; P<4,-1>='PYMT.TYPE'
  P<1,-1>='PENDING.CODE*'               ; P<2,-1>='Pending Code'
  P<3,-1>='PENDING_CODE_TBL_NF'         ; P<4,-1>='PENDING.CODE.TBL'
  P<1,-1>='POLICY.STATUS*'              ; P<2,-1>='Policy Status'
  P<3,-1>='TB_POLICY_STATUS_NF'         ; P<4,-1>='POLICY.STATUS_NON_UD'
  P<1,-1>='PROGRAM.CONTROL*'            ; P<2,-1>='Program Control'
  P<3,-1>='TB_PROGRAM_CONTROL_NF'       ; P<4,-1>='PROGRAM.CONTROL_NON_UD'
  P<1,-1>='PUR.OPT*'                    ; P<2,-1>='Purchase Option'
  P<3,-1>='PURCHASE_OPTION_TABLE_NF'    ; P<4,-1>='PURCHASE.OPTION.TABLE'
  P<1,-1>='PURPOSE.LOAN*'               ; P<2,-1>='Purpose Of Loan'
  P<3,-1>='TB_PURPOSE_OF_LOAN_NF'       ; P<4,-1>='PURPOSE.OF.LOAN_NON_UD'
  P<1,-1>='PUT.TO*'                     ; P<2,-1>='Put To'
  P<3,-1>='TB_PUT_TO_NF'                ; P<4,-1>='PUT.TO_NON_UD'
  P<1,-1>='QUOTE.BUYOUT*'               ; P<2,-1>='Quote Buyout'
  P<3,-1>='QUOTE_BUYOUT_TBL_NF'         ; P<4,-1>='QUOTE.BUYOUT.TBL'
  P<1,-1>='RCPT*'                       ; P<2,-1>='Void Receipt Reason'
  P<3,-1>='TB_VOID_RECEIPT_REASON_NF'   ; P<4,-1>='VOID.RECEIPT.REASON_NON_UD'
  P<1,-1>='RECOURSE*'                   ; P<2,-1>='Recourse'
  P<3,-1>='TB_RECOURSE_CODE_NF'         ; P<4,-1>='RECOURSE.CODE_NON_UD'
  P<1,-1>='RECOVERY.STATUS*'            ; P<2,-1>='Recovery Status'
  P<3,-1>='TB_RECOVERY_STATUS_NF'       ; P<4,-1>='RECOVERY.STATUS_NON_UD'
  P<1,-1>='RELATIONSHIP*'               ; P<2,-1>='Relationship'
  P<3,-1>='RELATIONSHIP_DATA_NF'        ; P<4,-1>='RELATIONSHIP.DATA'
  P<1,-1>='REM.PUR.OPTION*'             ; P<2,-1>='Remarketing Purchase Option'
  P<3,-1>='TB_REMARKETING_PURCHASE_NF'  ; P<4,-1>='REMARKETING.PURCH.OPT_NON_UD'
  P<1,-1>='RENEWAL.OPTION*'             ; P<2,-1>='Renewal Option'
  P<3,-1>='RENEWAL_OPTION_NF'           ; P<4,-1>='RENEWAL.OPTION'
  P<1,-1>='REPO.STATUS*'                ; P<2,-1>='Repossession Status'
  P<3,-1>='REPOSSESSION_CODE_NF'        ; P<4,-1>='REPOSSESSION.CODE'
  P<1,-1>='RESERVE*'                    ; P<2,-1>='Reserve Code'
  P<3,-1>='TB_RESERVE_CODE_NF'          ; P<4,-1>='RESERVE.CODE_NON_UD'
  P<1,-1>='RESIDUAL.GUAR*'              ; P<2,-1>='Residual Guarantee'
  P<3,-1>='TB_RESIDUAL_GUARANTEE_NF'    ; P<4,-1>='RESIDUAL.GUARANTEE_NON_UD'
  P<1,-1>='RESIDUAL.OWNER*'             ; P<2,-1>='Residual Owner'
  P<3,-1>='TB_RESIDUAL_OWNER_NF'        ; P<4,-1>='RESIDUAL.OWNER_NON_UD'
  P<1,-1>='RESIDUAL.SHARING*'           ; P<2,-1>='Residual Sharing'
  P<3,-1>='TB_RESIDUAL_SHARING_NF'      ; P<4,-1>='RESIDUAL.SHARING_NON_UD'
  P<1,-1>='RESTOCKING.FEE*'             ; P<2,-1>='Restocking Fee Obligation'
  P<3,-1>='TB_RESTOCK_FEE_OBLIGATIO_NF' ; P<4,-1>='RESTOCK.FEE.OBLIGATION_NON_UD'
  P<1,-1>='RETURN.COSTS.PD*'            ; P<2,-1>='Return Costs Paid'
  P<3,-1>='TB_RETURN_COSTS_PAID_NF'     ; P<4,-1>='RETURN.COSTS.PAID_NON_UD'
  P<1,-1>='REVS.PT*'                    ; P<2,-1>='REVS Plate Type'
  P<3,-1>='TB_REVS_PLATE_TYPE_NF'       ; P<4,-1>='REVS.PLATE.TYPE_NON_UD'
  P<1,-1>='REVS.ST*'                    ; P<2,-1>='REVS State'
  P<3,-1>='TB_REVS_STATE_NF'            ; P<4,-1>='REVS.STATE_NON_UD'
  P<1,-1>='SCAN.LINE.DE*'               ; P<2,-1>='Scan Line (Inv. Interface)'
  P<3,-1>='INV_INT_DATA_ELEMENTS_NF'    ; P<4,-1>='INV.INT.DATA.ELEMENTS'
  P<1,-1>='SCORE.DECISION*'             ; P<2,-1>='Credit Score Decision'
  P<3,-1>='TB_CREDIT_SCORE_DECISION_NF' ; P<4,-1>='CREDIT.SCORE.DECISION_NON_UD'
  P<1,-1>='SCORE.STATUS*'               ; P<2,-1>='Credit Score Status'
  P<3,-1>='CREDIT_SCORE_STATUS_NF'      ; P<4,-1>='CREDIT.SCORE.STATUS'
  P<1,-1>='SCORING.CODE*'               ; P<2,-1>='Scoring Code'
  P<3,-1>='SCORING_CODE_NF'             ; P<4,-1>='SCORING.CODE'
  P<1,-1>='SEC.PARTY*'                  ; P<2,-1>='Secure Party'
  P<3,-1>='LESSOR_SEC_PARTY_NF'         ; P<4,-1>='LESSOR.SEC.PARTY'
  P<1,-1>='SOURCE*'                     ; P<2,-1>='Source'
  P<3,-1>='TB_SOURCE_NF'                ; P<4,-1>='SOURCE_NON_UD'
  P<1,-1>='SPECIAL.INST*'               ; P<2,-1>='Special Instructions'
  P<3,-1>='TB_SPECIAL_INSTRUCTIONS_NF'  ; P<4,-1>='SPECIAL.INSTRUCTIONS_NON_UD'
  P<1,-1>='SPLIT.DE*'                   ; P<2,-1>='Invoice Interface Data Elements'
  P<3,-1>='INV_INT_DATA_ELEMENTS_NF'    ; P<4,-1>='INV.INT.DATA.ELEMENTS'
  P<1,-1>='SSP'                         ; P<2,-1>='System Security'
  P<3,-1>='SC_SECURE_PARAM_NF'          ; P<4,-1>='SC.SECURE.PARAM'
  P<1,-1>='UCC.STATE*'                  ; P<2,-1>='Filing State'
  P<3,-1>='FILING_STATE_NF'             ; P<4,-1>='FILING.STATE'
  P<1,-1>='UCC.STATUS*'                 ; P<2,-1>='Filing Status'
  P<3,-1>='FILING_STATUS_TABLE_NF'      ; P<4,-1>='FILING.STATUS.TABLE'
  P<1,-1>='UCC.TITLE.CODE*'             ; P<2,-1>='Filing Code'
  P<3,-1>='FILING_CODE_NF'              ; P<4,-1>='FILING.CODE'
  P<1,-1>='UK.POOL*'                    ; P<2,-1>='UK Pool'
  P<3,-1>='UK_POOL_NUM_NF'              ; P<4,-1>='UK.POOL.NUM'
  P<1,-1>='USG.ASSET.DE*'               ; P<2,-1>='Usage Asset (Inv. Interface)'
  P<3,-1>='INV_INT_DATA_ELEMENTS_NF'    ; P<4,-1>='INV.INT.DATA.ELEMENTS'
  P<1,-1>='USG.CHRG.DE*'                ; P<2,-1>='Usage Charge (Inv. Interface)'
  P<3,-1>='INV_INT_DATA_ELEMENTS_NF'    ; P<4,-1>='INV.INT.DATA.ELEMENTS'
  P<1,-1>='VLMAKE*'                     ; P<2,-1>='Vehicle Make'
  P<3,-1>='TB_VEHICLE_MAKE_NF'          ; P<4,-1>='VEHICLE.MAKE_NON_UD'
  P<1,-1>='VLMODEL*'                    ; P<2,-1>='Vehicle Model'
  P<3,-1>='TB_VEHICLE_MODEL_NF'         ; P<4,-1>='VEHICLE.MODEL_NON_UD'
  P<1,-1>='VLOPT*'                      ; P<2,-1>='Vehicle Option'
  P<3,-1>='TB_VEHICLE_OPTION_NF'        ; P<4,-1>='VEHICLE.OPTION_NON_UD'
  P<1,-1>='WAREHOUSE*'                  ; P<2,-1>='Warehouse Location'
  P<3,-1>='TB_WAREHOUSE_LOCATION_NF'    ; P<4,-1>='WAREHOUSE.LOCATION_NON_UD'
  P<1,-1>='WHOLESALE.PLAN*'             ; P<2,-1>='Wholesale Plan'
  P<3,-1>='TB_WHOLESALE_PLAN_NF'        ; P<4,-1>='WHOLESALE.PLAN_NON_UD'
  P<1,-1>='WL.FOLLOW-UP.CODE*'          ; P<2,-1>='Worklist Follow-Up Codes'
  P<3,-1>='WORKLIST_FOLLOW_UP_CODES_NF' ; P<4,-1>='WORKLIST.FOLLOW.UP.CODES'
  P<1,-1>='WP.PARAM'                    ; P<2,-1>='Word Processing'
  P<3,-1>='WP_PARAM_NF'                 ; P<4,-1>='WP.PARAM'
  P<1,-1>=STR('-', 18)                  ; P<2,-1>=STR('-',33)
  P<3,-1>=STR('-',30)                   ; P<4,-1>=STR('-',30)
  *
  IF ANS='/NOLIST' THEN RETURN
  PARAM.SEARCH = UPCASE(FIELD(ANS, ' ', 2))
  MAX.P = DCOUNT(P<1>, @VM)
  FOR F = 1 TO MAX.P
    SEARCH.STRING = UPCASE(P<1,F>:' ':P<2,F>:' ':P<3,F>:' ':P<4,F>)
    PRINT.LINE = PARAM.SEARCH = '' OR INDEX(SEARCH.STRING, PARAM.SEARCH, 1) > 0 OR F < 4 OR F = MAX.P
    IF PRINT.LINE THEN PRINT '|':P<1,F>'L#18':'|':P<2,F>'L#33':'|':P<3,F>'L#30':'|':P<4,F>'L#30':'|'
  NEXT F
RETURN
*
